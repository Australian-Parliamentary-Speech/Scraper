var documenterSearchIndex = {"docs":
[{"location":"summaries/#Summaries","page":"Summaries","title":"Summaries","text":"This page contains some summary statistics we have calculated for our scraping result.","category":"section"},{"location":"summaries/#Number-of-sitting-days-detected-for-each-year","page":"Summaries","title":"Number of sitting days detected for each year","text":"   using CSV, DataFrames\n   using Latexify\n   using Dates\n   using ParlinfoSpeechScraper\n\n   current_year = year(today())\n\n   parent_dir = pathof(ParlinfoSpeechScraper)\n   dir_ = joinpath(dirname(dirname(parent_dir)),\"test\")\n   nothing","category":"section"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"Here we start with the description of the user interface regarding inputs and outputs. Details about some structurally important functions are listed after.","category":"section"},{"location":"usage/#Inputs","page":"Usage","title":"Inputs","text":"The input xml files live in the directory src/Inputs/, and specifically where they live is specified in the toml file. For example, as currently stated in Inputs/hansard/hansard.toml, the xmls live in src/Inputs/hansard/xmls. You can define your own toml and your own directory of where the xmls live. To run the program, head to the src/ directory and run:\n\n./run Inputs/hansard/house.toml\n\nor \n\n./run <insert your toml file>","category":"section"},{"location":"usage/#Input-toml-file","page":"Usage","title":"Input toml file","text":"The input toml file allows the user to select options for the run. The output directory, the year range, whether the first step of the process is done and whether edit is preferred are the options that the user can edit. In terms of what files the program runs, we have two modes available when running the program. It can run one xml file or a directory of xml files.\n\nIn this section, we give a comprehensive explanation of all the toml options, and provides some quick starts that you can use for senate or house.\n\noutput_path (under [ global ]): \nwhere to save the final CSV files after processing\nExample: if set to \"../../Outputs/HouseCSV/hansard\", files will be saved there \npath (under [[ XML_DIR ]]):\nYou can either run one single file or one entire directory. \nExample for an entire directory: \"house_xmls\" will process all XML files in that folder\nExample for a single file: \"house_xmls/1983/1983_11_09.xml\" processes just that one file\n\nwhich_house (under [general_options] )\nOptions: \"house\" for House of Representatives, \"senate\" for Senate\n\nyear (under [general_options])\nWhich years to process\nExample: [1996,1997] processes years 1996 and 1997\nExample: [2000,2000] processes only year 2000\nxml_parsing (under [general_options])\nWhether to skip scraping \ntrue = extract data from XML files\nfalse = skip scraping, assuming there exists outputs \nedit (under [general_options])\nProcessing steps to clean and format the data\nThese run in the order listed - each step processes the output of the previous step\nCommon steps: \"speaker_time\", \"re\", \"free_node\", \"flatten\", \"column_decorate\" (more explanation see below)\nThe order matters. It is strongly recommended to use the list provided in the sample file for the best outcome \ncsv_edit \nWhether to apply editing operations to CSV files\ntrue = apply edits \nfalse = skip edits, keep raw extracted data\nrun_xml_toggle\nMaster switch for all XML processing functions\ntrue = run all XML processing steps normally\nfalse = skip all XML functions, only write samples or remove processing steps. \nsample\nWhether to create sample output files for testing\ntrue = create smaller sample files to check if processing works correctly\nfalse = process all data without creating samples\nremove_nums \nWhich intermediate CSV files to delete after processing (to save disk space)\nThe program creates files named like \"data_step_0.csv\", \"data_step_1.csv\", etc.\nThis setting deletes those intermediate files, keeping only the final result\nExample: [0,1,2,3,4,5,6] deletes steps 0 through 6 (keeps only the final step)\nExample: [0,1,2] deletes only the first 3 intermediate files\nExample: [] keeps all intermediate files (uses more disk space)\nxml_name_clean\nWhether to clean up XML filenames for inconsistent date formats\ntrue = rename files to standard format\nfalse = keep original filenames","category":"section"},{"location":"usage/#Quick-start-input-files","page":"Usage","title":"Quick start input files","text":"For a single xml file (for senate):\n\n[ global ]\n    output_path = \"../../Outputs/SenateCSV/hansard\"\n\n[[ XML ]]\n    filename = \"senate_xmls/1999/1999_06_25.xml\"\n\n[ general_options ]\n    which_house = \"senate\"\n    year = [1901,2025]\n    xml_parsing = true\n    edit = [\"speaker_time\",\"re\",\"stage_direction\",\"free_node\",\"flatten\",\"flatten\",\"column_decorate\",\"final_re\"]\n    csv_edit = true\n    run_xml_toggle = true\n    sample = true\n    remove_nums = [0,1,2,3,4,5,6,7]\n    xml_name_clean = false\n\nNote that if the date for the single xml is out of range from the year defined, the program might not run.\n\nFor a directory of xmls (for Senate):\n\n[ global ]\n    output_path = \"../../Outputs/SenateCSV/hansard\"\n\n[[ XML_DIR ]]\n    path = \"senate_xmls\"\n\n[ general_options ]\n    which_house = \"senate\"\n    year = [1901,2025]\n    xml_parsing = true\n    edit = [\"speaker_time\",\"re\",\"free_node\",\"flatten\",\"flatten\",\"column_decorate\",\"re\"]\n    csv_edit = true\n    run_xml_toggle = true\n    sample = false\n    remove_nums = [0,1,2,3,4,5,6]\n    xml_name_clean = false\n\nFor a single xml file (for House):\n\n[ global ]\n    output_path = \"../Outputs/HouseCSV/hansard\"\n\n[[ XML ]]\n    filename = \"hansard/house_xmls/2010/2010_02_10.xml\"\n\n[ general_options ]\n    which_house = \"senate\"\n    year = [1901,2025]\n    xml_parsing = true\n    edit = [\"speaker_time\",\"re\",\"stage_direction\",\"free_node\",\"flatten\",\"flatten\",\"column_decorate\",\"final_re\"]\n    csv_edit = true\n    run_xml_toggle = true\n    sample = true\n    remove_nums = [0,1,2,3,4,5,6,7]\n    xml_name_clean = false\n\nNote that if the date for the single xml is out of range from the year defined, the program might not run.\n\nFor a directory of xmls (for House):\n\n[ global ]\n    output_path = \"../Outputs/HouseCSV/hansard\"\n\n###choose one: XML or XML_DIR\n#[[ XML ]]\n#    filename = \"hansard/house_xmls/2010/2010_02_10.xml\"\n\n[[ XML_DIR ]]\n    path = \"../../Download/house_xmls\"\n\n[[ XML_DIR ]]\n    path = \"../../sgml2xml/house_reserve_xmls\"\n\n[[ XML_DIR ]]\n    path = \"../../sgml2xml/house_xmls\"\n\n\n[ general_options ]\n    which_house = \"house\"\n    year = [1901,2025]\n    xml_parsing = true\n    edit = [\"speaker_time\",\"re\",\"stage_direction\",\"free_node\",\"flatten\",\"flatten\",\"column_decorate\",\"final_re\"]\n    csv_edit = true\n    run_xml_toggle = true\n    sample = true\n    remove_nums = [0,1,2,3,4,5,6,7]\n    xml_name_clean = false","category":"section"},{"location":"usage/#Edit-steps","page":"Usage","title":"Edit steps","text":"","category":"section"},{"location":"usage/#stage_direction","page":"Usage","title":"stage_direction","text":"Identifies and standardises procedural (non-speech) rows.\n\nDetects parliamentary stage directions using known procedural phrases\nClears speaker attribution for procedural rows","category":"section"},{"location":"usage/#speaker_time-(often-not-used)","page":"Usage","title":"speaker_time (often not used)","text":"Extracts timing and auxiliary information from speech rows.\n\nSeparates embedded time markers from speech content into a dedicated time column\nAdds new columns for speaker label, time, and other extracted metadata\nMoves non-speaker or descriptive labels into an auxiliary “Other” field","category":"section"},{"location":"usage/#re","page":"Usage","title":"re","text":"Extracts speaker information and cleans speech text.\n\nIdentifies speaker names embedded in speech content and moves them to the speaker column\nDetects and labels interjections\nMakes an attempt to infer missing speaker names from structured text\nRemoves speaker labels, punctuation artefacts, and formatting noise from speech content\nDrops rows with empty speech content","category":"section"},{"location":"usage/#free_node","page":"Usage","title":"free_node","text":"Resolves unattributed (“free-flowing”) rows within a debate.\n\nAssigns free or missing speaker names to the most recent valid speaker in the same debate\nAttributes quoted or continued speech to the correct speaker where possible\nDoes not cross debate or sub-debate boundaries\nRemoves placeholder speaker labels from the output","category":"section"},{"location":"usage/#flatten","page":"Usage","title":"flatten","text":"Flattens multi-row speeches into single rows.\n\nMerges consecutive speech rows from the same speaker into one row\nAppends child speech content to the parent speech\nStops merging when a new speaker, debate context, or stage direction is encountered\nEnsures each speech appears only once in the output","category":"section"},{"location":"usage/#final_re","page":"Usage","title":"final_re","text":"Applies final cleaning and standardisation to the CSV output.\n\nFills missing speaker names from available speaker metadata\nReclassifies rows with speaker information as speech\nCleans speech text by removing leading punctuation and excess whitespace\nDrops rows with empty speech content","category":"section"},{"location":"advusage/#Advanced-usage","page":"Advanced Usage","title":"Advanced usage","text":"","category":"section"},{"location":"advusage/#How-to-introduce-a-new-node-to-the-algorithm","page":"Advanced Usage","title":"How to introduce a new node to the algorithm","text":"Here is a template for adding a new node to the program in the default phase. If a node is needed for a particular phase, simply exchange the path from \"nodes/\" to \"nodes/Phases/<yourphase>/nodes/\". \n\nexport ExampleNode\n\n#defining a new abstract type for the node\nabstract type ExampleNode{P} <: AbstractNode{P} end\n\n#what are the xpaths associated with the node\nfunction get_xpaths(::Type{<:ExampleNode})\n    return [\"xpath1\",\"xpath2\"]\nend\n\nThe code above provides a starting point for adding a new node. The algorithm will now recognise the new nodes with xpath1 and xpath2 as nodenames. The default function process_node is defined in NodeModule.jl. If a different process_node function is preferred (same goes with any other already defined functions), a new process_node can be defined in the present file in this way:\n\nfunction process_node(node::Node{<:ExampleNode},node_tree)\n    <insertyourcodehere>\nend","category":"section"},{"location":"advusage/#How-to-introduce-a-new-phase-into-the-algorithm","page":"Advanced Usage","title":"How to introduce a new phase into the algorithm","text":"In the directory nodes/Phases/, make a new directory\"Phases/ExamplePhase/\". Make a new directory \"Phases/ExamplePhase/nodes/\" to harbour new node definitions. Create a new phase julia file in the ExamplePhase directory PhaseExample.jl. An example starting file  is given here:\n\n\nabstract type PhaseExample <: AbstractPhase end\n\n# Get Phase Node Overrides\nphase_node_path = joinpath(@__DIR__, \"nodes\")\n\nfor path in readdir(phase_node_path, join=true)\n    if isfile(path)\n        include(path)\n    end\nend\n\n# define which phase is this new phase defined over.\ndate_to_float converts a date year,month,day to float. For example, if the range of the phase goes from 1st Jan 1901 tp 6th Dec 1901:\nupperbound = date_to_float(1901,12,6)\nlowerbound = date_to_float(1901,1,1)\ndate_to_phase[(lowerbound,upperbound)] = PhaseExample\n\nYou can then add any new definition for node processing in the \"Phases/ExamplePhase/nodes\" directory.","category":"section"},{"location":"advusage/#If-the-new-phase-is-for-senate","page":"Advanced Usage","title":"If the new phase is for senate","text":"To define a new phase for senate is similar to adding a new phase in house. In the directory nodes/Phases/, make a new directory\"Phases/ExamplePhase/\". Make a new directory \"Phases/ExamplePhase/nodes/\" to harbour new node definitions. Create a new phase julia file in the ExamplePhase directory PhaseExample.jl. An example starting file for senate is given here:\n\nabstract type PhaseExample <: AbstractPhase end\n\n# Get Phase Node Overrides\nphase_node_path = joinpath(@__DIR__, \"nodes\")\n\nfor path in readdir(phase_node_path, join=true)\n    if isfile(path)\n        include(path)\n    end\nend\n\n# define which phase is this new phase defined over.\ndate_to_float converts a date year,month,day to float. For example, if the range of the phase goes from 1st Jan 1901 tp 6th Dec 1901:\nupperbound = date_to_float(1901,12,6)\nlowerbound = date_to_float(1901,1,1)\ndate_to_phase_senate[(lowerbound,upperbound)] = PhaseExample\n\nIf no phase for senate is defined, the phase detection defaults to phase detection for house.","category":"section"},{"location":"advusage/#How-to-add-a-new-flag","page":"Advanced Usage","title":"How to add a new flag","text":"To add a new flag, or a new column of content, you would only need to interact with two functions: define_flags and define_headers. The dictionary that contains all information gets passed around and content gets added into it as the parsing goes on. The headers_dict sets all headers to \"N/A\" to start with and they get overwritten during running. ","category":"section"},{"location":"advusage/#How-to-add-a-new-edit-step","page":"Advanced Usage","title":"How to add a new edit step","text":"To add a new step in editting the CSVs, head to src/edit_funcs and create your own file, for example, your_edit_process.jl. For the sake of clarity, it would be good to give the same name to the julia file and this function you create (as shown below). \n\n# if you created your own Phase, replace the ::Type{<:AbstractEditPhase} with your own Phase\nfunction your_edit_process(input_fn,output_fn,::Type{<:AbstractEditPhase})\n    csvfile = CSV.File(input_fn)\n    #load all the headers such as speech_flag, content, speaker...\n    headers_ = copy(propertynames(csvfile))\n    # a dictionary to get which column to interact with. For example, if you want content, you do row[header_to_num[:content]] once you have rows\n    header_to_num = edit_set_up(headers_)\n    # a reverse dictionary of num_to_header in case it is useful\n    num_to_header = reverse_dict(header_to_num)\n    rows = eachrow(csvfile)\n    open(output_fn,\"w\") do io\n        write_row_to_io(io,string.(new_headers))\n        for row in rows\n            new_row = your_edit_fund(row)\n            write_row_to_io(io,new_row)\n        end\n    end\nend \n\nOnce the file is written, append this name of the function into edit option, for example:\n\n    edit = [\"speaker_time\",\"re\",\"free_node\",\"flatten\",\"flatten\",\"column_decorate\",\"re\", \"your_edit_process\"]\n ","category":"section"},{"location":"functionreference/#Function-references","page":"Function references","title":"Function references","text":"","category":"section"},{"location":"functionreference/#RunModule","page":"Function references","title":"RunModule","text":"","category":"section"},{"location":"functionreference/#XMLModule","page":"Function references","title":"XMLModule","text":"","category":"section"},{"location":"functionreference/#NodeModule","page":"Function references","title":"NodeModule","text":"","category":"section"},{"location":"functionreference/#ParlinfoSpeechScraper.get_args-Tuple{}","page":"Function references","title":"ParlinfoSpeechScraper.get_args","text":"get_args()\n\nParse command-line arguments\n\nThis function sets up and parses command-line arguments using the ArgParse package. It defines the arguments that can be passed to the script, including options for verbosity and input file path.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.main-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.main","text":"main(toml_path, verbose)\n\nMain function to initialize and execute the Parlinfo Speech Scraper\n\nThis function initializes the input configuration from a TOML file specified by toml_path with optional verbosity controlled by verbose. It then runs the ParlinfoSpeechScraper using the configuration.\n\nInputs:\n\ntoml_path: Path to the TOML configuration file.\nverbose: Boolean flag indicating if logging verbosity should be increased.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.main-Tuple{}","page":"Function references","title":"ParlinfoSpeechScraper.main","text":"main()\n\n\nMain function to process command-line arguments and run the program\n\nThis function serves as the entry point of the script. It processes command-line arguments, retrieves the necessary parameters, and calls the main processing function with those parameters.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.get_date-Tuple{Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.get_date","text":"get_date(fn)\n\nGet the date from the xml file\n\nInputs:\n\nfn: the file directory for the xml file\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.recurse","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.recurse","text":"recurse(soup, date, PhaseType, xmlnode, io, index=1, depth=0, maxdepth=0, node_tree=Vector{Node}())\n\nRecursively process XML nodes and write data to output\n\nThis function recursively processes XML nodes, extracts relevant data, and writes it to an output stream. It handles node types, depth limitations, and maintains a tree of processed nodes.\n\nInputs:\n\nsoup: The parsed XML document.\ndate: The date associated with the XML document.\nPhaseType: The phase type determined from the date.\nxml_node: The current XML node being processed.\nio: The output stream where data is written.\nindex (optional): The index of the current node (default is 1).\ndepth (optional): The current depth of recursion (default is 0).\nmax_depth (optional): The maximum depth for recursion (default is 0, meaning no limit).\nnode_tree (optional): A vector maintaining the tree of nodes (default is an empty vector).\n\n\n\n\n\n","category":"function"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.run_ParlinfoSpeechScraper-Tuple{Dict{String, Any}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.run_ParlinfoSpeechScraper","text":"run_ParlinfoSpeechScraper(toml::Dict{String, Any})\n\nThis function processes XML files for parliamentary speeches according to the configuration specified in the provided TOML dictionary. It reads XML file paths, processes each XML file, and outputs the results to a specified directory.\n\nInputs:\n\ntoml: A dictionary containing configuration options for the scraper.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.run_xml-NTuple{7, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.run_xml","text":"run_xml(fn, output_path, csv_exist, edit_funcs)\n\nProcess and save XML data to CSV\n\nThis function processes an XML file, extracts relevant data, and saves it to a CSV file. If specified, it also edits the CSV file after creation.\n\nInputs:\n\nfn: The file path for the XML file.\noutput_path: The directory where the processed CSV file will be saved.\ncsv_exist: Boolean flag indicating if a CSV file already exists.\nedit_funcs: list of edit functions\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.edit_main-Tuple{Any, Editor}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.edit_main","text":"func_list: a list of function names as string editor: a struct with two parameters\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.edit_set_up-Tuple{Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.edit_set_up","text":"editsetup(headers)\n\nSets up a dictionary mapping each element in headers to its corresponding index.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.find_all_child_speeches-NTuple{4, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.find_all_child_speeches","text":"function findallchildspeeches(rowno,rows,headertonum,is_written)\n\nFind all the speeches that belong to a single talker \n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.find_all_flags-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.find_all_flags","text":"get all flags except chamber flag\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.free_node_op-NTuple{5, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.free_node_op","text":"if it is free flowing, check if it is same debate and add it to the previous one\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.define_flags-Tuple{Node, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.define_flags","text":"defineflags(node::Node{<:AbstractNode{<:AbstractPhase}}, nodetree)\n\nGenerates flags based on the characteristics of the given node.\n\nInputs:\n\nnode: A Node struct.\nnode_tree: A vector representing a tree of nodes for context.\n\nReturns:\n\nAn array of flags indicating characteristics of node\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.define_flags-Tuple{Node{<:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.define_flags","text":"defineflags(node::Node{<:AbstractNode{Phase2011}},parentnode,node_tree)\n\nAdded petition and quote nodes on top of the previous flags\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.detect_node_type-NTuple{4, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.detect_node_type","text":"detectnodetype(node, node_tree, date, soup, PhaseType)\n\ndefault setting:\n\nInputs:\n\nnode: The XML node to determine the type for.\nnode_tree: A vector representing a tree of nodes\nsoup: The root node.\nPhaseType: The phase type determined from the date of XML.\n\nReturns:\n\nThe detected node type (NodeType).\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.detect_phase-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.detect_phase","text":"detectphase(date, whichhouse)\n\nInputs:\n\ndate: A floating-point number representing the date to detect the phase for.\nhouse: A string that indicates either senate or house\n\nReturns:\n\nThe phase associated with the provided date, or AbstractPhase if no specific phase is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.find_chamber-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_chamber","text":"findchamber(node, nodetree)\n\nIdentifies the type of chamber associated with the given XML node.\n\nInputs:\n\nnode: The XML node \nnode_tree: A vector representing a tree of nodes for context.\n\nReturns:\n\nAn integer indicating the chamber type:\n2 for a federal chamber (FedChamberNode).\n1 for a chamber (ChamberNode).\n0 if no chamber node is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.find_section_title-Tuple{Any, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_section_title","text":"findsectiontitle(nodetree, soup, sectiontype)\n\nInputs:\n\nnode: The XML node from which to extract the section title.\nnode_tree: A vector representing a tree of nodes for context.\nsoup: The root node of the XML document.\nsection_type: The nodenames of the types of section nodes where the title is wanted. For example, \"speech\".\n\nReturns:\n\nThe title of the specified section_type found within the XML document, or \"N/A\" if not found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.find_talker_in_p-Tuple{Node{<:PNode}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_talker_in_p","text":"findtalkerinp(pnode)\n\nIf the pnode is not the first pnode, we check if there is a talker inside the p_node.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_all_subtypes","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_all_subtypes","text":"get_all_subtypes(type, st=[])\n\nGet every subtype of the provided type parameter.\n\nInputs:\n\ntype: the provided type\n\n\n\n\n\n","category":"function"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{<:PNode}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{<:PNode})\n\nIn which sections are the p_node wanted as default.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{PNode{Phase2011}})\n\nAllowed sections for PNodes.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.PhaseSGML}}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{PNode{PhaseSGML}})\n\nAllowed sections for PNodes.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_talker_from_parent-Tuple{Node, Node}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_talker_from_parent","text":"gettalkerfromparent(node::Node,parentnode::Node)\n\nIt finds the speaker information from the parent node\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{<:InterTalkNode}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{<:InterTalkNode})\n\nThe default setting for what nodenames are allowed for intertalknode.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{<:PNode}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{<:PNode})\n\nFind what the p_node is called in xml for default\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{PNode{Phase2011}})\n\n\"para\" as accepted xpaths for PNode.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.PhaseSGML}}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{PNode{PhaseSGML}})\n\n\"para\" as accepted xpaths for PNode.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Union{Tuple{Type{<:N}}, Tuple{N}} where N<:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{<:N}) where {N <: AbstractNode}\n\nThis function serves as a placeholder and returns an empty array, which is meant to provide the nodenames allowed for each type. For example, speech nodes can have names \"speech\" or \"continue\". \n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type-Tuple{Node{<:PNode}, Any, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type","text":"isfirstnodetype(node::Node{<:PNode},parentnode,allowednames,nodetree)\n\nThis default function detects if the pnode detected is the first pnode under a parent node. The reason for this is that if the p_node is not the first node, there are alternative checks to see if the talker has changed since the first one.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type-Tuple{Node{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}, Any, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type","text":"isfirstnodetype(node::Node{PNode{Phase2011}},parentnode,allowednames,nodetree)\n\nA different method to detect if the pnode is the first pnode for this phase\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{<:PNode}, Type{<:AbstractPhase}, Any, Vararg{Any}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype","text":"isnodetype(node, nodetree, nodetype::Type{<:PNode},phase::Type{<:AbstractPhase},soup, args...; kwargs...) \n\nThis function detects whether the given xml node is PNode. This function takes the phase into account aswell.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{<:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode}, Type{<:AbstractPhase}, Any, Vararg{Any}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype","text":"isnodetype(node, nodetree, nodetype::Type{<:AbstractNode}, phase::Type{<:AbstractPhase}, soup, args...; kwargs...)\n\ndefault setting:\n\nInputs:\n\nnode: The XML node to evaluate.\nnode_tree: A vector representing a tree of nodes for context.\nnodetype: A subtype of AbstractNode representing the type of node to check against.\nphase: A subtype of AbstractPhase representing the phase associated with the node.\nsoup: The root node.\nargs...: Optional additional arguments.\nkwargs...: Optional keyword arguments.\n\nReturns:\n\ntrue if the name of node is found in the allowed names associated with nodetype for the given phase, false otherwise.\n\nNotes: More specific detection method for nodes is defined in nodes/\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.p_with_a_as_parent-Tuple{Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.p_with_a_as_parent","text":"pwithaasparent(p_node)\n\nIf no talker is found for the first node, we look for a \"a\" as parentnode.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.parse_node-Tuple{Node, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.parse_node","text":"parsenode(node::Node, nodetree, io)\n\ndefault setting:\n\nInputs:\n\nnode: xml node of Node struct\nnode_tree: A vector representing a tree of nodes for context.\nio: The output stream where processed data is written.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.parse_node-Tuple{Node{<:PNode}, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.parse_node","text":"parsenode(node::Node{<:PNode},nodetree,io)\n\nThe default function to take a p_node and write to the csv\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.process_node","text":"processnode(node::Node, nodetree)\n\ndefault setting:\n\nInputs:\n\nnode: xml node of Node struct\nnode_tree: A vector representing a tree of nodes for context.\n\nNotes:\n\nThis function is typically invoked when no specific processing behavior is defined for the NodeType associated with node.\nUsers may customize or define specific behaviors for different NodeType instances within their implementation.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node{<:PNode}, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.process_node","text":"processnode(node::Node{<:PNode},nodetree)\n\nIf no particular phase is specified, this default version of process node is run. \n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_name-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_name","text":"reversefindfirstnodename(node_tree, names)\n\nInputs:\n\nnode_tree: A vector representing a tree of nodes to search in reverse order.\nnames: A collection of node names to search for.\n\nReturns:\n\nThe first node from node_tree in reverse order whose name is in the names collection, or nothing if no such node is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_not_name-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_not_name","text":"reversfindfirstnodenotname(nodetree, names)\n\nInputs:\n\nnode_tree: A vector representing a tree of nodes to search in reverse order.\nnames: A collection of node names. The function searches for the first node from node_tree in reverse order whose name is not in this collection.\n\nReturns:\n\nThe first node from node_tree in reverse order whose name is not in the names collection, or nothing if no such node is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.write_test_xml-Tuple{Any, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.write_test_xml","text":"Writes the test xmls for all edge cases: it cannot handle dummy parent as root itself – soup is getting passed and not document type\n\n\n\n\n\n","category":"method"},{"location":"test/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"test/#How-to-test","page":"Testing","title":"How to test","text":"Head into Scraper directory after cloning, in terminal type: julia\n\nIn Julia REPL, press ]\n\nThen run test by test\n\nThe suite of tests will be run. ","category":"section"},{"location":"test/#Gold-standard-testing","page":"Testing","title":"Gold standard testing","text":"To ensure the quality of our data extraction process—from XML files to CSV files before database upload—we use a gold-standard testing approach. This helps us measure how accurately our scraper reproduces the information contained in Hansard documents.\n\nGold-standard CSV files refer to manually corrected CSV files. These files are produced by research assistants who compare:\n\nthe scraped CSV output  \nthe original XML  \nand the corresponding PDF version of Hansard\n\nThe gold-standard files correct only computationally feasible errors, such as mis-split speeches or missing flags, but they do not fix issues that are impossible to correct automatically (e.g., typos in the original XML).\n\nEach pair of files—gold standard vs scraped output—is evaluated using a similarity score, which measures how closely our output matches the gold standard.","category":"section"},{"location":"test/#How-the-Similarity-Score-Works","page":"Testing","title":"How the Similarity Score Works","text":"There are two key challenges when comparing two CSV files:\n\nRow counts may differ, because speeches may be merged or split.\nThe same row may not appear in the same position, so we need a reliable way to match rows.\n\nTo address this, we use the speech content as the row identifier, since it is typically the most unique attribute.","category":"section"},{"location":"test/#Two-Matching-Modes","page":"Testing","title":"Two Matching Modes","text":"We support two matching modes:","category":"section"},{"location":"test/#1.-Exact-Mode","page":"Testing","title":"1. Exact Mode","text":"In exact mode, the full speech text from the gold standard is used to find an identical match in the scraped output.\n\nLimitation: even a tiny difference—like a missing space or a changed quotation mark—can prevent a match.This can cause the score to appear lower than it should be.","category":"section"},{"location":"test/#2.-Fuzzy-Mode","page":"Testing","title":"2. Fuzzy Mode","text":"To reduce false mismatches, fuzzy mode uses partial text sampling instead of the full speech.\n\nHow it works:\n\nExtract short samples from the gold standard speech.\nEach sample is a set of consecutive words.\nSearch for these samples in the scraped output.\nIf multiple candidate rows match the samples, select the one that is overall most similar to the gold standard speech.\n\nThis allows us to match rows even when minor differences exist.","category":"section"},{"location":"test/#Scoring","page":"Testing","title":"Scoring","text":"Once a row is matched, the similarity score for that row is calculated as:\n\nRow similarity = (number of matching cells) / (total number of cells)\n\nThe test system in test/runtests.jl implements a comprehensive comparison framework between gold standard CSV files and generated sample CSV files with similarity ratio calculation. The system compares generated CSV outputs against gold standard files stored in test/gold_standard/ by first copying sample files from the main output directory to test/sample_csv/, then calculating two types of similarity ratios using the similarity_csv function in similarity_funcs.jl:1. The comparison works by matching rows based on content fields, then checking all other columns except those specified in the skip_cols parameter. It returns two ratios: success/length(gs\\_rows) (exact matches) and content_success/length(gs\\_rows) (content-based matches), allowing users to specify which columns to ignore during comparison via the test_setup.skip_cols vector in the test_struct defined at runtests.jl:16-18. The system can be run by uncommenting lines 150-155 in runtests.jl and customizing the skip_cols array with column names like :speaker_no, :stage_direction_flag, or Symbol(\"page.no\") to exclude specific columns from the similarity calculation.","category":"section"},{"location":"test/#Input-test-toml-file","page":"Testing","title":"Input test toml file","text":"This testing requires two toml files, one is the same input file for the Scraper program (with slight modification of the output_path), and the other one specifically designed for this testing suite. ","category":"section"},{"location":"test/#Test-Parameters","page":"Testing","title":"Test Parameters","text":"skip_cols   A list of column names to exclude from the similarity comparison.  \nwhich_test   Specifies the matching strategy used to align rows between the gold-standard CSV and the scraped output.  \n\"exact\": Rows are matched only if the full speech text matches exactly.  \n\"fuzzy\": Rows are matched using sampled word sequences from the speech text, allowing for minor textual differences.\nfuzzy_search   Controls how speech text is sampled in fuzzy matching mode.   This option is only used when which_test = \"fuzzy\".   The value is a two-element array:\nThe first element specifies the number of consecutive words in each sample.\nThe second element specifies the step size (interval) between successive samples.  \nFor example, [5, 2] means that samples of 5 consecutive words are taken, starting every 2 words along the speech.\nwhich_house   Indicates which parliamentary house the data belongs to and should be tested against.   This is used to select the appropriate gold-standard reference files and parsing rules.   Common values include:\n\"house\": House of Representatives  \n\"senate\": Senate","category":"section"},{"location":"test/#Sample-input-file","page":"Testing","title":"Sample input file","text":"[ test_params ]\n    skip_cols = [\"speaker_no\",\"non_speech_flag\",\"page.no\",\"name\",\"electorate\",\"party\",\"role\",\"path\",\"Speaker\",\"Time\",\"Other\"]\n    #or exact\n    which_test = \"fuzzy\"\n    fuzzy_search = [5,2]\n    which_house = \"house\"","category":"section"},{"location":"nodes/#Nodes","page":"Nodes","title":"Nodes","text":"This document describes what each Julia file in src/nodes does during XML parsing, including the crucial phase-specific processing that handles different time periods and XML formats in parliamentary data.","category":"section"},{"location":"nodes/#Phase-System-Overview","page":"Nodes","title":"Phase System Overview","text":"The system processes parliamentary transcripts from different time periods with different XML structures:\n\nPhaseSGML (1981-1997): Earlier SGML-based format \nPhase2011 (1998-2011): Later XML format with different structure\nDefault Phase: Modern format (post-2011)\n\nEach phase has different XML tag names, processing rules, and output formats.\n\nThe phase system ensures that parliamentary transcripts from different eras are processed consistently while preserving their unique structural characteristics and historical context.","category":"section"},{"location":"nodes/#Base-Node-Processing-Workflows","page":"Nodes","title":"Base Node Processing Workflows","text":"","category":"section"},{"location":"nodes/#AnswerNode.jl-Answer-Processing","page":"Nodes","title":"AnswerNode.jl - Answer Processing","text":"What it does:\n\nBase behavior: Looks for <answer> XML tags in parliamentary transcripts\nContinuation handling: When it finds a \"continue\" element, checks if the parent node is actually an answer node\nValidation: Confirms that the current XML element should be treated as an answer before processing","category":"section"},{"location":"nodes/#AnswersToQuestionsNode.jl-Answer-Collection-Processing","page":"Nodes","title":"AnswersToQuestionsNode.jl - Answer Collection Processing","text":"What it does:\n\nSession marker: Identifies <answers.to.questions> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#BusinessNode.jl-Business-Start-Processing","page":"Nodes","title":"BusinessNode.jl - Business Start Processing","text":"What it does:\n\nSession marker: Identifies <business.start> tags \nSimple recognition: No content extraction - just recognizes when business proceedings begin","category":"section"},{"location":"nodes/#ChamberNode.jl-Chamber-Transcript-Processing","page":"Nodes","title":"ChamberNode.jl - Chamber Transcript Processing","text":"What it does:\n\nContainer identification: Identifies <chamber.xscript> elements\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#DebateNode.jl-Debate-Section-Processing","page":"Nodes","title":"DebateNode.jl - Debate Section Processing","text":"What it does:\n\nSession marker: Identifies <debate> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins\nTitle extraction: Extracts debate title information from /debateinfo/title path within the debate\nLegacy filtering: Contains commented logic that would filter out debates titled \"BILLS\" (currently disabled)","category":"section"},{"location":"nodes/#DivisionNode.jl-Voting-Division-Processing","page":"Nodes","title":"DivisionNode.jl - Voting Division Processing","text":"What it does:\n\nSession marker: Identifies <division> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#FedChamberNode.jl-Federal-Chamber-Processing","page":"Nodes","title":"FedChamberNode.jl - Federal Chamber Processing","text":"What it does:\n\nMulti-name support: Identifies both <fedchamb.xscript> (federal chamber) and <maincomm.xscript> (main committee) transcript sections\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#InterTalkNode.jl-Inter-Speaker-Dialogue-Processing","page":"Nodes","title":"InterTalkNode.jl - Inter-Speaker Dialogue Processing","text":"What it does:\n\nContent extraction: Looks for <talk.start> elements and extracts text from //talk.text paths\nMissing content handling: If no talk text is found, sets content to a space character\nSpeaker identification: Gets talker information from the parent node in the node tree\nContext validation: Ensures the talk is happening within an interjection section","category":"section"},{"location":"nodes/#InterjectionNode.jl-Interjection-Section-Processing","page":"Nodes","title":"InterjectionNode.jl - Interjection Section Processing","text":"What it does:\n\nSession marker: Identifies <interjection> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#PNode.jl-Paragraph-Content-Processing-(Most-Complex,-Highly-Phase-Specific)","page":"Nodes","title":"PNode.jl - Paragraph Content Processing (Most Complex, Highly Phase-Specific)","text":"Base PNode (Default Phase) - uses <p> tags:\n\nContext identification: Looks for <p> tags within speeches, questions, answers, or business sections\nFirst paragraph detection: Determines if this is the first <p> element under its parent node\nSpeaker extraction: Gets speaker from parent node or searches within paragraph content\nContent processing: Handles item labels, cleans text, builds complete records\n\nPhase2011 PNode - uses <para> tags:\n\nDifferent XML structure: Processes <para> tags instead of <p> tags\nExpanded section support: Can appear in more section types including AdjournmentNode, SubdebateNode\nAdvanced first-node detection: \nAlways treats nodes under MotionnospeechNode as first\nChecks for \"talker\" elements two nodes back to determine if it's a first paragraph\nQuote node handling: Special logic where quote nodes act like paragraph containers\nInterTalk integration: Special handling when paragraphs appear within InterTalkNode contexts\n\nPhaseSGML PNode - uses <para> tags with SGML-specific features:\n\nSGML format processing: Handles older SGML-based XML structure with <para> tags\nParent finding logic: Uses special find_p_node_parent() function for complex parent relationships\nFont-based quote detection: Identifies quotes by checking @font-size=\"-=2\" attribute\nNonspeech node detection: Identifies non-speech content in \"NOTICES\" and \"PAPERS\" sections\nSpecial flag handling: Adds nonspeech flag for administrative content without speakers","category":"section"},{"location":"nodes/#QuestionNode.jl-Question-Processing","page":"Nodes","title":"QuestionNode.jl - Question Processing","text":"What it does:\n\nQuestion identification: Identifies <question> XML elements in Q&A sessions\nContinuation support: Handles \"continue\" elements by validating parent node context","category":"section"},{"location":"nodes/#SpeechNode.jl-Speech-Processing","page":"Nodes","title":"SpeechNode.jl - Speech Processing","text":"What it does:\n\nSpeech recognition: Identifies <speech> XML elements in parliamentary transcripts\nContinuation handling: Processes \"continue\" elements by checking parent node validity","category":"section"},{"location":"nodes/#SubdebateNode.jl-Subdebate-Processing","page":"Nodes","title":"SubdebateNode.jl - Subdebate Processing","text":"What it does:\n\nSession marker: Identifies <subdebate.1> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins\nTitle extraction: Gets subdebate title information from /subdebateinfo/title path","category":"section"},{"location":"nodes/#Phase-Specific-Node-Files","page":"Nodes","title":"Phase-Specific Node Files","text":"","category":"section"},{"location":"nodes/#Phase2011-Specific-Nodes-(src/nodes/Phases/Phase2011/nodes/)","page":"Nodes","title":"Phase2011 Specific Nodes (src/nodes/Phases/Phase2011/nodes/)","text":"","category":"section"},{"location":"nodes/#AdjournmentNode.jl-Phase2011-Adjournment-Processing","page":"Nodes","title":"AdjournmentNode.jl - Phase2011 Adjournment Processing","text":"What it does:\n\nSession marker: Identifies <adjournment> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins\nPhase-specific structure: Only exists in Phase2011, handles 1998-2011 adjournment format","category":"section"},{"location":"nodes/#InterTalkNode.jl-Phase2011-Inter-Talk-Processing-(Disabled)","page":"Nodes","title":"InterTalkNode.jl - Phase2011 Inter-Talk Processing (Disabled)","text":"What it does:\n\nRecognition only: Identifies <talk.start> elements but doesn't process them\nDisabled processing: process_node() and parse_node() functions return nothing\nSimple validation: Just checks if node name matches allowed XPath patterns","category":"section"},{"location":"nodes/#MotionnospeechNode.jl-Phase2011-Motion-Without-Speech","page":"Nodes","title":"MotionnospeechNode.jl - Phase2011 Motion Without Speech","text":"What it does:\n\nSession marker: Identifies <motionnospeech> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#PetitionNode.jl-Phase2011-Petition-Processing","page":"Nodes","title":"PetitionNode.jl - Phase2011 Petition Processing","text":"What it does:\n\nSession marker: Identifies <petition> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#QuoteNode_.jl-Phase2011-Quote-Processing","page":"Nodes","title":"QuoteNode_.jl - Phase2011 Quote Processing","text":"What it does:\n\nSession marker: Identifies <quote> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#PhaseSGML-Specific-Nodes-(src/nodes/Phases/PhaseSGML/nodes/)","page":"Nodes","title":"PhaseSGML Specific Nodes (src/nodes/Phases/PhaseSGML/nodes/)","text":"","category":"section"},{"location":"nodes/#DebateNode.jl-PhaseSGML-Debate-Processing","page":"Nodes","title":"DebateNode.jl - PhaseSGML Debate Processing","text":"What it does:\n\nSGML debate formats: Handles multiple debate names: <debate>, <qwn>, <answer.to.qon>\nTitle extraction: Gets titles from /title path instead of /debateinfo/title","category":"section"},{"location":"nodes/#InterTalkNode.jl-PhaseSGML-Inter-Talk-Processing-(Disabled)","page":"Nodes","title":"InterTalkNode.jl - PhaseSGML Inter-Talk Processing (Disabled)","text":"What it does:\n\nDisabled processing: Both process_node() and parse_node() return nothing\nFormat incompatibility: Inter-talk processing is turned off for SGML format","category":"section"},{"location":"nodes/#InterjectionNode.jl-PhaseSGML-Interjection-Processing","page":"Nodes","title":"InterjectionNode.jl - PhaseSGML Interjection Processing","text":"What it does:\n\nSession marker: Identifies <interject> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#MotionnospeechNode.jl-PhaseSGML-Motion-Without-Speech","page":"Nodes","title":"MotionnospeechNode.jl - PhaseSGML Motion Without Speech","text":"What it does:\n\nSession marker: Identifies <motionnospeech> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#PetitionNode.jl-PhaseSGML-Petition-Processing","page":"Nodes","title":"PetitionNode.jl - PhaseSGML Petition Processing","text":"What it does:\n\nExtended petition names: Recognizes both <petition> and <petition.grp> elements\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#QuoteNode_.jl-PhaseSGML-Quote-Processing","page":"Nodes","title":"QuoteNode_.jl - PhaseSGML Quote Processing","text":"What it does:\n\nSession marker: Identifies <quote> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"section"},{"location":"nodes/#SubdebateNode.jl-PhaseSGML-Subdebate-Processing","page":"Nodes","title":"SubdebateNode.jl - PhaseSGML Subdebate Processing","text":"What it does:\n\nExtended subdebate names: Recognizes both <subdebate.1> and <question.block> as subdebates\nSimple recognition: No content extraction - just recognizes when this section begins\nTitle extraction: Uses /title path instead of /subdebateinfo/title","category":"section"},{"location":"nodes/#Phase-Processing-Summary","page":"Nodes","title":"Phase Processing Summary","text":"","category":"section"},{"location":"nodes/#Phase2011-(1998-2011)-Features:","page":"Nodes","title":"Phase2011 (1998-2011) Features:","text":"Date Range: 1998-2011 and historical 1901-1980 data\nNew Node Types: AdjournmentNode for session boundaries\nDisabled Features: InterTalkNode processing turned off\nEnhanced Paragraphs: More complex parent-child relationships in PNode\nAdditional Content Types: Petition, quote, motionnospeech support","category":"section"},{"location":"nodes/#PhaseSGML-(1981-1997)-Features:","page":"Nodes","title":"PhaseSGML (1981-1997) Features:","text":"SGML Format: Older document structure with different tag names\nExtended Recognition: More debate types (qwn, answer.to.qon)\nDifferent Tags: <interject> instead of <interjection>\nGrouped Content: Petition groups (petition.grp)\nDisabled Features: InterTalkNode processing turned off","category":"section"},{"location":"nodes/#Processing-Differences-Across-Phases:","page":"Nodes","title":"Processing Differences Across Phases:","text":"Tag Names: Different XML element names for same concepts\nHierarchical Structure: Different parent-child relationships\nContent Detection: Different methods for identifying quotes, speakers, etc.\nFeature Availability: Some processing features disabled in certain phases\nOutput Headers: Different metadata fields in final CSV output\nValidation Rules: Phase-specific logic for determining node types","category":"section"},{"location":"nodes/#Header-Systems-Across-Phases","page":"Nodes","title":"Header Systems Across Phases","text":"Each phase defines different header configurations for the final CSV output:","category":"section"},{"location":"nodes/#Default-Phase-(GenericPhase)-NodeModule.jl:464","page":"Nodes","title":"Default Phase (GenericPhase) - NodeModule.jl:464","text":"question_flag: 1 if within QuestionNode, 0 otherwise\nanswer_flag: 1 if within AnswerNode, 0 otherwise\ninterjection_flag: 1 if within InterjectionNode, 0 otherwise\nspeech_flag: 1 if within SpeechNode, 0 otherwise\nchamber_flag: Chamber type (0=none, 1=chamber, 2=federal, 3=answers)\nname: Speaker name\nname.id: Speaker ID\nelectorate: Speaker's electorate\nparty: Speaker's political party\nrole: Speaker's parliamentary role\npage.no: Page number in original document\ncontent: Text content of the node\nsubdebateinfo: Title of subdebate section\ndebateinfo: Title of debate section\npath: XML path to the node","category":"section"},{"location":"nodes/#Phase2011-(1998-2011)-Phase2011.jl:44","page":"Nodes","title":"Phase2011 (1998-2011) - Phase2011.jl:44","text":"All default headers above, plus:\n\npetition_flag: 1 if within PetitionNode, 0 otherwise\nquote_flag: 1 if within QuoteNode, 0 otherwise\nmotionnospeech_flag: 1 if within MotionnospeechNode, 0 otherwise","category":"section"},{"location":"nodes/#PhaseSGML-(1981-1997)-PhaseSGML.jl:37","page":"Nodes","title":"PhaseSGML (1981-1997) - PhaseSGML.jl:37","text":"All Phase2011 headers above, plus:\n\nnonspeech: 1 for administrative content in \"NOTICES\"/\"PAPERS\" sections with no speaker, 0 otherwise\n\nThe header system progressively adds more content classification capabilities in later phases while maintaining backward compatibility with core parliamentary data fields.","category":"section"},{"location":"sgml2xml/#Download-the-SGML-files-and-convert-them-to-XML-files","page":"XML download (1981-1997)","title":"Download the SGML files and convert them to XML files","text":"This step downloads the SGML files and converts them into XML files (they are missing from Hansard). \n\nStep one, in your preferred directory, clone the sgml2xml repo with HTTP or SSH:\n\ngit clone https://github.com/Australian-Parliamentary-Speech/sgml2xml.git\n\nGo into the directory\n\ncd sgml2xml\n\nIn the directory, run:\n\n./run house\n\nor \n\n./run senate\n\nThe XML files should be in the directory senate_xmls or house_xmls","category":"section"},{"location":"sgml2xml/#required-file:","page":"XML download (1981-1997)","title":"required file:","text":"hansard.dtd (converts sgml to xml) HansardSGML.csv (all the links required) sgml2xml.jl download_utils.jl  run (bash script)","category":"section"},{"location":"common_errors/#Common-Errors","page":"Common errors and warnings","title":"Common Errors","text":"The codebase includes several error messages for debugging and validation purposes:\n\nNodeModule.jl:81: @error \"which_house is not correctly given\"\nif which_house is not senate or house\nQuestionNode.jl:23: @error \"No phase was produced in questionnode\" \nindicates missing phase data in question processing\nSpeechNode.jl:22: @error \"No phase was produced in speechnode\"\nindicates missing phase data in speech processing","category":"section"},{"location":"download/#Download-the-XML-files","page":"XML download","title":"Download the XML files","text":"This step downloads all the available XML files from the Hansard directly\n\nStep one, in your preferred directory, clone the Download repo with HTTP or SSH:\n\ngit clone https://github.com/Australian-Parliamentary-Speech/Download.git\n\nGo into the directory:\n\ncd Download\n\nIn the directory, run:\n\n./run house\n\nor\n\n./run senate\n\nThe XML files should be in the directory sitemap_xmls_senate or sitemap_xmls_house.","category":"section"},{"location":"download/#Required-files","page":"XML download","title":"Required files","text":"XML_download_method1.jl\n\nutils.jl\n\ndownload_utils.jl \n\nrun (bash file)","category":"section"},{"location":"download/#logfile","page":"XML download","title":"logfile","text":"The logfiles are in sitemap_logfiles/. It contains information on how many links in total were detected (to compare with the parlinfo website) and how many missing were updated from this run.","category":"section"},{"location":"download/#To-update-the-download","page":"XML download","title":"To update the download","text":"The update process does not download all files again, it downloads only the files that are not present in the current directory. \n\nThe same command above can be used again to update the XMLs: In the directory, run:\n\n./run house\n\nor\n\n./run senate\n\nThe program will detect what already exists and update what is not there. For this to work, please do not delete any folders generated from the last run. An error will occur if you run the program twice in a day. This is to prevent over-writing. ","category":"section"},{"location":"download/#Implementation-details","page":"XML download","title":"Implementation details","text":"","category":"section"},{"location":"download/#Step-1:-download-the-first-layer-XML-pages","page":"XML download","title":"Step 1: download the first layer XML pages","text":"The first step downloads each XML page provided by the first sitemap. Each of these pages would contain a list of HTML links. This step will run every time regardless if previous runs were conducted. The reason for that is this first link gets updated with overwritten names everytime. ","category":"section"},{"location":"download/#Step-2:-extract-all-the-html-links","page":"XML download","title":"Step 2: extract all the html links","text":"The second step extracts all the HTML links from the XML files downloaded in step 1 into a csv file sitemap_html_step2_<dateofcreation>.csv.","category":"section"},{"location":"download/#Step-3:-compare-the-current-csv-with-any-existing-file","page":"XML download","title":"Step 3: compare the current csv with any existing file","text":"This step is run if any other csv from the previous run is detected. It compares the csv generated in step 2 and the previous csv and generate a csv file containing the HTML links in current run and not in the previous run. The resulting file would be named sitemap_html_step2_missing.csv.\n\nIf no existing previous run is detected, this step will not run.","category":"section"},{"location":"download/#Step-4:-download-the-html-files","page":"XML download","title":"Step 4: download the html files","text":"This step downloads all the HTML files either from the missing ones or the entire csv from step 2, depending on if previous run was detected. The html files will be downloaded to directory sitemap_htmls_step4_<dateofcreation>. If any file has failed t download, the links would appear in the log file in directory sitemap_logfiles/.","category":"section"},{"location":"download/#Step-5:-extract-the-xml-links","page":"XML download","title":"Step 5: extract the xml links","text":"This step extracts all the missing xml links (or the complete set) into a csv called site_map_xml_step5_<dateofcreation>.csv","category":"section"},{"location":"download/#Step-6:-download-the-xml-files","page":"XML download","title":"Step 6: download the xml files","text":"This step downloads the xml files from the links provided in step 5 into sitemap_xmls/.","category":"section"},{"location":"download/#Step-7:-add-the-new-xml-links-into-the-existing-file-and-remove-the-old-run.","page":"XML download","title":"Step 7: add the new xml links into the existing file and remove the old run.","text":"This step just cleans up the old files and gets ready for the next run. The total number of links detected will also show up in the logfile to compare with the result from https://parlinfo.aph.gov.au/parlInfo/search/summary/summary.w3p;adv%3Dyes;orderBy%3D_fragment_number,doc_date-rev;query%3DDataset%3Ahansardr,hansardr80;resCount%3DDefault. It is recommened to delete some of the sitemap_htmls_step4_<dateofcreation> so they don't stack up too much. But it is not necessary. ","category":"section"},{"location":"#ParlinfoSpeechScraper","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"This project is divided into three parts, which correspond to three repos: Download, sgml2xml, and Scraper. The repo Download downloads the XML files directly from the Parlinfo roadmap. The repo sgml2xml downloads the sgml files and convert them into XML files. This is for the years where the XML files are missing. Finally Scraper parses the XML files and produces CSV files that contain all the speech information. The detailed documentation is in the documentation page here. ","category":"section"},{"location":"#Windows-users","page":"ParlinfoSpeechScraper","title":"Windows users","text":"All commands here work natively for Mac and Linux users.\n\nSince this project uses bash scripts (e.g., ./run house), Windows users need a bash environment to run these commands. One option is to install Git Windows to create a bash shell environment. Once installed, right click \"Git Bash Here\" and run bash commands there. ","category":"section"},{"location":"#Install-Julia","page":"ParlinfoSpeechScraper","title":"Install Julia","text":"To run the package, Julia needs to be installed. For help see https://julialang.org/install/","category":"section"},{"location":"#Download-the-XML-files","page":"ParlinfoSpeechScraper","title":"Download the XML files","text":"Step one, in your preferred directory, for example HansardScraper/, clone the Download repo with HTTP or SSH:\n\ncd HansardScraper\n\ngit clone https://github.com/Australian-Parliamentary-Speech/Download.git\n\nGo into the directory:\n\ncd Download\n\nIn the directory (in a bash environment), run:\n\n./run house\n\nor\n\n./run senate\n\nThe XML files should be in the directory sitemapxmlssenate or sitemapxmlshouse.","category":"section"},{"location":"#Download-the-SGML-files-and-convert-them-to-XML-files","page":"ParlinfoSpeechScraper","title":"Download the SGML files and convert them to XML files","text":"Step one, in your preferred directory, for example HansardScraper/, clone the sgml2xml repo with HTTP or SSH:\n\ncd HansardScraper\n\ngit clone https://github.com/Australian-Parliamentary-Speech/sgml2xml.git\n\nGo into the directory\n\ncd sgml2xml\n\nIn the directory (in a bash environment), run:\n\n./run house\n\nor \n\n./run senate\n\nThe XML files should be in the directory senatexmls or housexmls","category":"section"},{"location":"#Parsing","page":"ParlinfoSpeechScraper","title":"Parsing","text":"Step one, in your preferred directory, for example HansardScraper/, clone this repo with HTTP or SSH:\n\ncd HansardScraper\n\ngit clone https://github.com/Australian-Parliamentary-Speech/Scraper.git\n\nGo into the directory:\n\ncd Scraper\n\nIf you have created these three directories in HansardScraper/ as the example, you can directory run in the directory:\n\nFor Senate: \n\n./run Inputs/hansard/senate.toml\n\nFor House:\n\n./run Inputs/hansard/house.toml\n\nIf you have created these directories differently, you would have to change the input directory in the house.toml file (details on how to change the file see here)\n\nThe output file will be in Outputs/SenateCSV or Outputs/HouseCSV\n\nTo run different year ranges or a specific year,senate.toml or house.toml file needs to be editted (details see here).\n\nFor Windows users:\n\nFor Senate:\n\nIn the directory (in a bash environment), run:\n\n./run Inputs/hansard/senate.toml\n\nFor House:\n\nIn the directory (in a bash environment), run:\n\n./run Inputs/hansard/house.toml\n\nIf you have created these directories differently, you would have to change the input directory in the house.toml file (details on how to change the file see here)\n\n#(# Overall structure  The documentation page is arranged as follows: Normal usage in terms of inputs and outputs is explained in Usage, and more advanced interaction that includes adding a node or phase type is explained in Advanced usage. The current implementation of different nodes in all phases is shown in Nodes. Function references shows all the docstrings in the program.)","category":"section"}]
}
