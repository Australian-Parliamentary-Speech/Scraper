var documenterSearchIndex = {"docs":
[{"location":"summaries/#Summaries","page":"Summaries","title":"Summaries","text":"","category":"section"},{"location":"summaries/","page":"Summaries","title":"Summaries","text":"This page contains some summary statistics we have calculated for our scraping result.","category":"page"},{"location":"summaries/#Number-of-sitting-days-detected-for-each-year","page":"Summaries","title":"Number of sitting days detected for each year","text":"","category":"section"},{"location":"summaries/","page":"Summaries","title":"Summaries","text":"   using CSV, DataFrames\n   using Latexify\n   using Dates\n   using ParlinfoSpeechScraper\n\n   current_year = year(today())\n\n   parent_dir = pathof(ParlinfoSpeechScraper)\n   dir_ = joinpath(dirname(dirname(parent_dir)),\"test\")\n   nothing","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here we start with the description of the user interface regarding inputs and outputs. Details about some structurally important functions are listed after.","category":"page"},{"location":"usage/#Inputs","page":"Usage","title":"Inputs","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The input xml files live in the directory src/Inputs/, and specifically where they live is specified in the toml file. For example, as currently stated in Inputs/hansard/hansard.toml, the xmls live in src/Inputs/hansard/xmls. You can define your own toml and your own directory of where the xmls live. To run the program, head to the src/ directory and run:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"./run Inputs/hansard/house.toml","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"or ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"./run <insert your toml file>","category":"page"},{"location":"usage/#Input-toml-file","page":"Usage","title":"Input toml file","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The input toml file allows the user to select options for the run. The output directory, the year range, whether the first step of the process is done and whether edit is preferred are the options that the user can edit. In terms of what files the program runs, we have two modes available when running the program. It can run one xml file or a directory of xml files.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In this section, we give an example of house.toml that has comprehensive explanation, and provides some quick starts that you can use for senate or house.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The comprehensive toml file with all options present:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Parliamentary Speech Scraper Configuration\n# This file tells the program what files to process and how to process them\n# Lines starting with # are comments and are ignored by the program\n\n[ global ]\n    # Where to save the final CSV files after processing\n    # Example: if set to \"../../Outputs/HouseCSV/hansard\", files will be saved there\n    output_path = \"../../Outputs/HouseCSV/hansard\"\n\n# Input Source: Choose ONE of these two options below\n# Either process a single XML file OR process all files in a directory\n\n### Option 1: Process a single specific XML file\n### Remove the # symbols below to activate this option (and add # to the XML_DIR section)\n#[[ XML ]]\n#    # Path to a specific XML file to process\n#    # Example: \"house_xmls/1983/1983_11_09.xml\" processes just that one file\n#    filename = \"house_xmls/1983/1983_11_09.xml\"\n\n### Option 2: Process all XML files in a directory (currently active)\n[[ XML_DIR ]]\n    # Folder containing XML files to process\n    # Example: \"house_xmls\" will process all XML files in that folder\n    path = \"house_xmls\"\n\n[ general_options ]\n    # Which parliamentary house to scrape\n    # Options: \"house\" for House of Representatives, \"senate\" for Senate\n    which_house = \"house\"\n    \n    # Which years to process\n    # Examples: [1996,1997] processes years 1996 and 1997\n    #          [2000,2000] processes only year 2000\n    #          [1990,2000] processes years 1990 through 2000\n    year = [1996,1997]\n    \n    # Whether to extract data from XML files\n    # true = extract data from XML files\n    # false = skip scraping, but editing steps will still run on existing data\n    xml_parsing = true\n    \n    # Processing steps to clean and format the data\n    # These run in the order listed - each step processes the output of the previous step\n    # Common steps: \"speaker_time\", \"re\", \"free_node\", \"flatten\", \"column_decorate\"\n    edit = [\"speaker_time\",\"re\",\"free_node\",\"flatten\",\"flatten\",\"column_decorate\",\"re\"]\n    \n    # Whether to apply editing operations to CSV files\n    # true = apply edits to make data cleaner and more usable\n    # false = skip edits, keep raw extracted data\n    csv_edit = true\n    \n    # Master switch for all XML processing functions\n    # true = run all XML processing steps normally\n    # false = skip all XML functions, only write samples or remove processing steps\n    run_xml_toggle = true\n    \n    # Whether to create sample output files for testing\n    # true = create smaller sample files to check if processing works correctly\n    # false = process all data without creating samples\n    sample = true\n    \n    # Which intermediate CSV files to delete after processing (to save disk space)\n    # The program creates files named like \"data_step_0.csv\", \"data_step_1.csv\", etc.\n    # This setting deletes those intermediate files, keeping only the final result\n    # Example: [0,1,2,3,4,5,6] deletes steps 0 through 6 (keeps only the final step)\n    #         [0,1,2] deletes only the first 3 intermediate files\n    #         [] keeps all intermediate files (uses more disk space)\n    remove_nums = [0,1,2,3,4,5,6]\n    \n    # Whether to clean up XML filenames\n    # true = rename files to standard format\n    # false = keep original filenames\n    xml_name_clean = false","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here are some quick starts:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For a single xml file (for senate):","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Where the output would go\n[ global ]\n    output_path = \"../../Outputs/SenateCSV/hansard\"\n\n# The XML file you run\n[[ XML ]]\n    filename = \"senate_xmls/1999/1999_06_25.xml\"\n\n[ general_options ]\n    # senate or house\n    which_house = \"senate\"\n    # year range\n    year = [1901,2025]\n    # false to skip scraping, edit still remains\n    xml_parsing = true\n    # steps for editting\n    edit = [\"speaker_time\",\"re\",\"free_node\",\"flatten\",\"flatten\",\"column_decorate\",\"re\"]\n    #false to skip edits\n    csv_edit = true\n    #false to skip all run xml functions and only to write samples or remove steps\n    run_xml_toggle = true\n    sample = false\n    # whether to remove some steps once program finishes\n    remove_nums = [0,1,2,3,4,5,6]\n    # does it require xml name cleaning to ensure dates are in the right format\n    xml_name_clean = false","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Note that if the date for the single xml is out of range from the year defined, the program might not run.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For a directory of xmls (for Senate):","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Where the output would go\n[ global ]\n    output_path = \"../../Outputs/SenateCSV/hansard\"\n\n# Where the input xmls are stored\n[[ XML_DIR ]]\n    path = \"senate_xmls\"\n\n[ general_options ]\n    # senate or house\n    which_house = \"senate\"\n    # year range\n    year = [1901,2025]\n    # false to skip scraping, edit still remains\n    xml_parsing = true\n    # steps for editting\n    edit = [\"speaker_time\",\"re\",\"free_node\",\"flatten\",\"flatten\",\"column_decorate\",\"re\"]\n    #false to skip edits\n    csv_edit = true\n    #false to skip all run xml functions and only to write samples or remove steps\n    run_xml_toggle = true\n    sample = false\n    # whether to remove some steps once program finishes\n    remove_nums = [0,1,2,3,4,5,6]\n    # does it require xml name cleaning to ensure dates are in the right format\n    xml_name_clean = false","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For a single xml file (for House):","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Where the output would go\n[ global ]\n    output_path = \"../../Outputs/HouseCSV/hansard\"\n\n# The XML file you run\n[[ XML ]]\n    filename = \"house_xmls/1999/1999_06_25.xml\"\n\n[ general_options ]\n    # senate or house\n    which_house = \"house\"\n    # year range\n    year = [1901,2025]\n    # false to skip scraping, edit still remains\n    xml_parsing = true\n    # steps for editting\n    edit = [\"speaker_time\",\"re\",\"free_node\",\"flatten\",\"flatten\",\"column_decorate\",\"re\"]\n    #false to skip edits\n    csv_edit = true\n    #false to skip all run xml functions and only to write samples or remove steps\n    run_xml_toggle = true\n    sample = false\n    # whether to remove some steps once program finishes\n    remove_nums = [0,1,2,3,4,5,6]\n    # does it require xml name cleaning to ensure dates are in the right format\n    xml_name_clean = false","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Note that if the date for the single xml is out of range from the year defined, the program might not run.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For a directory of xmls (for House):","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Where the output would go\n[ global ]\n    output_path = \"../../Outputs/HouseCSV/hansard\"\n\n# Where the input xmls are stored\n[[ XML_DIR ]]\n    path = \"house_xmls\"\n\n[ general_options ]\n    # senate or house\n    which_house = \"house\"\n    # year range\n    year = [1901,2025]\n    # false to skip scraping, edit still remains\n    xml_parsing = true\n    # steps for editting\n    edit = [\"speaker_time\",\"re\",\"free_node\",\"flatten\",\"flatten\",\"column_decorate\",\"re\"]\n    #false to skip edits\n    csv_edit = true\n    #false to skip all run xml functions and only to write samples or remove steps\n    run_xml_toggle = true\n    sample = false\n    # whether to remove some steps once program finishes\n    remove_nums = [0,1,2,3,4,5,6]\n    # does it require xml name cleaning to ensure dates are in the right format\n    xml_name_clean = false","category":"page"},{"location":"usage/#Outputs","page":"Usage","title":"Outputs","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Where the output files go can be edited by the user in the toml file shown above. Currently, they are stored in Outputs/hansard.","category":"page"},{"location":"advusage/#Advanced-usage","page":"Advanced Usage","title":"Advanced usage","text":"","category":"section"},{"location":"advusage/#How-to-introduce-a-new-node-to-the-algorithm","page":"Advanced Usage","title":"How to introduce a new node to the algorithm","text":"","category":"section"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"Here is a template for adding a new node to the program in the default phase. If a node is needed for a particular phase, simply exchange the path from \"nodes/\" to \"nodes/Phases/<yourphase>/nodes/\". ","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"export ExampleNode\n\n#defining a new abstract type for the node\nabstract type ExampleNode{P} <: AbstractNode{P} end\n\n#what are the xpaths associated with the node\nfunction get_xpaths(::Type{<:ExampleNode})\n    return [\"xpath1\",\"xpath2\"]\nend","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"The code above provides a starting point for adding a new node. The algorithm will now recognise the new nodes with xpath1 and xpath2 as nodenames. The default function process_node is defined in NodeModule.jl. If a different process_node function is preferred (same goes with any other already defined functions), a new process_node can be defined in the present file in this way:","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"function process_node(node::Node{<:ExampleNode},node_tree)\n    <insertyourcodehere>\nend","category":"page"},{"location":"advusage/#How-to-introduce-a-new-phase-into-the-algorithm","page":"Advanced Usage","title":"How to introduce a new phase into the algorithm","text":"","category":"section"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"In the directory nodes/Phases/, make a new directory\"Phases/ExamplePhase/\". Make a new directory \"Phases/ExamplePhase/nodes/\" to harbour new node definitions. Create a new phase julia file in the ExamplePhase directory PhaseExample.jl. An example starting file  is given here:","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"\nabstract type PhaseExample <: AbstractPhase end\n\n# Get Phase Node Overrides\nphase_node_path = joinpath(@__DIR__, \"nodes\")\n\nfor path in readdir(phase_node_path, join=true)\n    if isfile(path)\n        include(path)\n    end\nend\n\n# define which phase is this new phase defined over.\ndate_to_float converts a date year,month,day to float. For example, if the range of the phase goes from 1st Jan 1901 tp 6th Dec 1901:\nupperbound = date_to_float(1901,12,6)\nlowerbound = date_to_float(1901,1,1)\ndate_to_phase[(lowerbound,upperbound)] = PhaseExample","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"You can then add any new definition for node processing in the \"Phases/ExamplePhase/nodes\" directory.","category":"page"},{"location":"advusage/#If-the-new-phase-is-for-senate","page":"Advanced Usage","title":"If the new phase is for senate","text":"","category":"section"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"To define a new phase for senate is similar to adding a new phase in house. In the directory nodes/Phases/, make a new directory\"Phases/ExamplePhase/\". Make a new directory \"Phases/ExamplePhase/nodes/\" to harbour new node definitions. Create a new phase julia file in the ExamplePhase directory PhaseExample.jl. An example starting file for senate is given here:","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"abstract type PhaseExample <: AbstractPhase end\n\n# Get Phase Node Overrides\nphase_node_path = joinpath(@__DIR__, \"nodes\")\n\nfor path in readdir(phase_node_path, join=true)\n    if isfile(path)\n        include(path)\n    end\nend\n\n# define which phase is this new phase defined over.\ndate_to_float converts a date year,month,day to float. For example, if the range of the phase goes from 1st Jan 1901 tp 6th Dec 1901:\nupperbound = date_to_float(1901,12,6)\nlowerbound = date_to_float(1901,1,1)\ndate_to_phase_senate[(lowerbound,upperbound)] = PhaseExample","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"If no phase for senate is defined, the phase detection defaults to phase detection for house.","category":"page"},{"location":"advusage/#How-to-add-a-new-flag","page":"Advanced Usage","title":"How to add a new flag","text":"","category":"section"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"To add a new flag, or a new column of content, you would only need to interact with two functions: define_flags and define_headers. The dictionary that contains all information gets passed around and content gets added into it as the parsing goes on. The headers_dict sets all headers to \"N/A\" to start with and they get overwritten during running. ","category":"page"},{"location":"advusage/#How-to-add-a-new-edit-step","page":"Advanced Usage","title":"How to add a new edit step","text":"","category":"section"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"To add a new step in editting the CSVs, head to src/edit_funcs and create your own file, for example, your_edit_process.jl. For the sake of clarity, it would be good to give the same name to the julia file and this function you create (as shown below). ","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"# if you created your own Phase, replace the ::Type{<:AbstractEditPhase} with your own Phase\nfunction your_edit_process(input_fn,output_fn,::Type{<:AbstractEditPhase})\n    csvfile = CSV.File(input_fn)\n    #load all the headers such as speech_flag, content, speaker...\n    headers_ = copy(propertynames(csvfile))\n    # a dictionary to get which column to interact with. For example, if you want content, you do row[header_to_num[:content]] once you have rows\n    header_to_num = edit_set_up(headers_)\n    # a reverse dictionary of num_to_header in case it is useful\n    num_to_header = reverse_dict(header_to_num)\n    rows = eachrow(csvfile)\n    open(output_fn,\"w\") do io\n        write_row_to_io(io,string.(new_headers))\n        for row in rows\n            new_row = your_edit_fund(row)\n            write_row_to_io(io,new_row)\n        end\n    end\nend ","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"Once the file is written, append this name of the function into edit option, for example:","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"    edit = [\"speaker_time\",\"re\",\"free_node\",\"flatten\",\"flatten\",\"column_decorate\",\"re\", \"your_edit_process\"]\n ","category":"page"},{"location":"functionreference/#Function-references","page":"Function references","title":"Function references","text":"","category":"section"},{"location":"functionreference/#ParlinfoSpeechScraper.get_args-Tuple{}","page":"Function references","title":"ParlinfoSpeechScraper.get_args","text":"get_args()\n\nParse command-line arguments\n\nThis function sets up and parses command-line arguments using the ArgParse package. It defines the arguments that can be passed to the script, including options for verbosity and input file path.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.main-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.main","text":"main(toml_path, verbose)\n\nMain function to initialize and execute the Parlinfo Speech Scraper\n\nThis function initializes the input configuration from a TOML file specified by toml_path with optional verbosity controlled by verbose. It then runs the ParlinfoSpeechScraper using the configuration.\n\nInputs:\n\ntoml_path: Path to the TOML configuration file.\nverbose: Boolean flag indicating if logging verbosity should be increased.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.main-Tuple{}","page":"Function references","title":"ParlinfoSpeechScraper.main","text":"main()\n\n\nMain function to process command-line arguments and run the program\n\nThis function serves as the entry point of the script. It processes command-line arguments, retrieves the necessary parameters, and calls the main processing function with those parameters.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#RunModule","page":"Function references","title":"RunModule","text":"","category":"section"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.get_date-Tuple{Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.get_date","text":"get_date(fn)\n\nGet the date from the xml file\n\nInputs:\n\nfn: the file directory for the xml file\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.recurse","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.recurse","text":"recurse(soup, date, PhaseType, xmlnode, io, index=1, depth=0, maxdepth=0, node_tree=Vector{Node}())\n\nRecursively process XML nodes and write data to output\n\nThis function recursively processes XML nodes, extracts relevant data, and writes it to an output stream. It handles node types, depth limitations, and maintains a tree of processed nodes.\n\nInputs:\n\nsoup: The parsed XML document.\ndate: The date associated with the XML document.\nPhaseType: The phase type determined from the date.\nxml_node: The current XML node being processed.\nio: The output stream where data is written.\nindex (optional): The index of the current node (default is 1).\ndepth (optional): The current depth of recursion (default is 0).\nmax_depth (optional): The maximum depth for recursion (default is 0, meaning no limit).\nnode_tree (optional): A vector maintaining the tree of nodes (default is an empty vector).\n\n\n\n\n\n","category":"function"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.run_ParlinfoSpeechScraper-Tuple{Dict{String, Any}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.run_ParlinfoSpeechScraper","text":"run_ParlinfoSpeechScraper(toml::Dict{String, Any})\n\nThis function processes XML files for parliamentary speeches according to the configuration specified in the provided TOML dictionary. It reads XML file paths, processes each XML file, and outputs the results to a specified directory.\n\nInputs:\n\ntoml: A dictionary containing configuration options for the scraper.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.run_xml-NTuple{7, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.run_xml","text":"run_xml(fn, output_path, csv_exist, edit_funcs)\n\nProcess and save XML data to CSV\n\nThis function processes an XML file, extracts relevant data, and saves it to a CSV file. If specified, it also edits the CSV file after creation.\n\nInputs:\n\nfn: The file path for the XML file.\noutput_path: The directory where the processed CSV file will be saved.\ncsv_exist: Boolean flag indicating if a CSV file already exists.\nedit_funcs: list of edit functions\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#XMLModule","page":"Function references","title":"XMLModule","text":"","category":"section"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.edit_main-Tuple{Any, Editor}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.edit_main","text":"func_list: a list of function names as string editor: a struct with two parameters\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.edit_set_up-Tuple{Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.edit_set_up","text":"editsetup(headers)\n\nSets up a dictionary mapping each element in headers to its corresponding index.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.find_all_child_speeches-NTuple{4, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.find_all_child_speeches","text":"function findallchildspeeches(rowno,rows,headertonum,is_written)\n\nFind all the speeches that belong to a single talker \n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.find_all_flags-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.find_all_flags","text":"get all flags except chamber flag\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.free_node_op-NTuple{6, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.free_node_op","text":"if it is free flowing, check if it is same debate and add it to the previous one\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#NodeModule","page":"Function references","title":"NodeModule","text":"","category":"section"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.define_flags-Tuple{Node, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.define_flags","text":"defineflags(node::Node{<:AbstractNode{<:AbstractPhase}}, nodetree)\n\nGenerates flags based on the characteristics of the given node.\n\nInputs:\n\nnode: A Node struct.\nnode_tree: A vector representing a tree of nodes for context.\n\nReturns:\n\nAn array of flags indicating characteristics of node\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.define_flags-Tuple{Node{<:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.define_flags","text":"defineflags(node::Node{<:AbstractNode{Phase2011}},parentnode,node_tree)\n\nAdded petition and quote nodes on top of the previous flags\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.detect_node_type-NTuple{5, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.detect_node_type","text":"detectnodetype(node, node_tree, date, soup, PhaseType)\n\ndefault setting:\n\nInputs:\n\nnode: The XML node to determine the type for.\nnode_tree: A vector representing a tree of nodes\ndate: The date associated with the node.\nsoup: The root node.\nPhaseType: The phase type determined from the date of XML.\n\nReturns:\n\nThe detected node type (NodeType).\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.detect_phase-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.detect_phase","text":"detectphase(date, whichhouse)\n\nInputs:\n\ndate: A floating-point number representing the date to detect the phase for.\nhouse: A string that indicates either senate or house\n\nReturns:\n\nThe phase associated with the provided date, or AbstractPhase if no specific phase is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.find_chamber-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_chamber","text":"findchamber(node, nodetree)\n\nIdentifies the type of chamber associated with the given XML node.\n\nInputs:\n\nnode: The XML node \nnode_tree: A vector representing a tree of nodes for context.\n\nReturns:\n\nAn integer indicating the chamber type:\n2 for a federal chamber (FedChamberNode).\n1 for a chamber (ChamberNode).\n0 if no chamber node is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.find_section_title-Tuple{Any, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_section_title","text":"findsectiontitle(nodetree, soup, sectiontype)\n\nInputs:\n\nnode: The XML node from which to extract the section title.\nnode_tree: A vector representing a tree of nodes for context.\nsoup: The root node of the XML document.\nsection_type: The nodenames of the types of section nodes where the title is wanted. For example, \"speech\".\n\nReturns:\n\nThe title of the specified section_type found within the XML document, or \"N/A\" if not found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.find_talker_in_p-Tuple{Node{<:PNode}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_talker_in_p","text":"findtalkerinp(pnode)\n\nIf the pnode is not the first pnode, we check if there is a talker inside the p_node.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_all_subtypes","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_all_subtypes","text":"get_all_subtypes(type, st=[])\n\nGet every subtype of the provided type parameter.\n\nInputs:\n\ntype: the provided type\n\n\n\n\n\n","category":"function"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{<:InterTalkNode}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{<:InterTalkNode})\n\nThe default setting for the sections where intertalknodes are processed\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{<:PNode}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{<:PNode})\n\nIn which sections are the p_node wanted as default.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{PNode{Phase2011}})\n\nAllowed sections for PNodes.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.PhaseSGML}}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{PNode{PhaseSGML}})\n\nAllowed sections for PNodes.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_talker_from_parent-Tuple{Node, Node}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_talker_from_parent","text":"gettalkerfromparent(node::Node,parentnode::Node)\n\nIt finds the speaker information from the parent node\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{<:InterTalkNode}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{<:InterTalkNode})\n\nThe default setting for what nodenames are allowed for intertalknode.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{<:PNode}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{<:PNode})\n\nFind what the p_node is called in xml for default\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{PNode{Phase2011}})\n\n\"para\" as accepted xpaths for PNode.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.PhaseSGML}}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{PNode{PhaseSGML}})\n\n\"para\" as accepted xpaths for PNode.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Union{Tuple{Type{<:N}}, Tuple{N}} where N<:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{<:N}) where {N <: AbstractNode}\n\nThis function serves as a placeholder and returns an empty array, which is meant to provide the nodenames allowed for each type. For example, speech nodes can have names \"speech\" or \"continue\". \n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type-Tuple{Node{<:PNode}, Any, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type","text":"isfirstnodetype(node::Node{<:PNode},parentnode,allowednames,nodetree)\n\nThis default function detects if the pnode detected is the first pnode under a parent node. The reason for this is that if the p_node is not the first node, there are alternative checks to see if the talker has changed since the first one.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type-Tuple{Node{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}, Any, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type","text":"isfirstnodetype(node::Node{PNode{Phase2011}},parentnode,allowednames,nodetree)\n\nA different method to detect if the pnode is the first pnode for this phase\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{<:InterTalkNode}, Type{<:AbstractPhase}, Any, Vararg{Any}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype","text":"isnodetype(node, nodetree, nodetype::Type{<:InterTalkNode},phase::Type{<:AbstractPhase},soup, args...; kwargs...) \n\nThis function checks if the given xml node is of nodetype InterTalkNode\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{<:PNode}, Type{<:AbstractPhase}, Any, Vararg{Any}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype","text":"isnodetype(node, nodetree, nodetype::Type{<:PNode},phase::Type{<:AbstractPhase},soup, args...; kwargs...) \n\nThis function detects whether the given xml node is PNode. This function takes the phase into account aswell.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{<:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode}, Type{<:AbstractPhase}, Any, Vararg{Any}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype","text":"isnodetype(node, nodetree, nodetype::Type{<:AbstractNode}, phase::Type{<:AbstractPhase}, soup, args...; kwargs...)\n\ndefault setting:\n\nInputs:\n\nnode: The XML node to evaluate.\nnode_tree: A vector representing a tree of nodes for context.\nnodetype: A subtype of AbstractNode representing the type of node to check against.\nphase: A subtype of AbstractPhase representing the phase associated with the node.\nsoup: The root node.\nargs...: Optional additional arguments.\nkwargs...: Optional keyword arguments.\n\nReturns:\n\ntrue if the name of node is found in the allowed names associated with nodetype for the given phase, false otherwise.\n\nNotes: More specific detection method for nodes is defined in nodes/\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.p_with_a_as_parent-Tuple{Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.p_with_a_as_parent","text":"pwithaasparent(p_node)\n\nIf no talker is found for the first node, we look for a \"a\" as parentnode.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.parse_node-Tuple{Node, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.parse_node","text":"parsenode(node::Node, nodetree, io)\n\ndefault setting:\n\nInputs:\n\nnode: xml node of Node struct\nnode_tree: A vector representing a tree of nodes for context.\nio: The output stream where processed data is written.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.parse_node-Tuple{Node{<:PNode}, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.parse_node","text":"parsenode(node::Node{<:PNode},nodetree,io)\n\nThe default function to take a p_node and write to the csv\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.process_node","text":"processnode(node::Node, nodetree)\n\ndefault setting:\n\nInputs:\n\nnode: xml node of Node struct\nnode_tree: A vector representing a tree of nodes for context.\n\nNotes:\n\nThis function is typically invoked when no specific processing behavior is defined for the NodeType associated with node.\nUsers may customize or define specific behaviors for different NodeType instances within their implementation.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node{<:InterTalkNode}, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.process_node","text":"processnode(node::Node{<:InterTalkNode},nodetree)\n\nThe default setting for processing intertalknodes.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node{<:PNode}, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.process_node","text":"processnode(node::Node{<:PNode},nodetree)\n\nIf no particular phase is specified, this default version of process node is run. \n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_name-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_name","text":"reversefindfirstnodename(node_tree, names)\n\nInputs:\n\nnode_tree: A vector representing a tree of nodes to search in reverse order.\nnames: A collection of node names to search for.\n\nReturns:\n\nThe first node from node_tree in reverse order whose name is in the names collection, or nothing if no such node is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_not_name-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_not_name","text":"reversfindfirstnodenotname(nodetree, names)\n\nInputs:\n\nnode_tree: A vector representing a tree of nodes to search in reverse order.\nnames: A collection of node names. The function searches for the first node from node_tree in reverse order whose name is not in this collection.\n\nReturns:\n\nThe first node from node_tree in reverse order whose name is not in the names collection, or nothing if no such node is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.write_test_xml-Tuple{Any, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.write_test_xml","text":"Writes the test xmls for all edge cases: it cannot handle dummy parent as root itself – soup is getting passed and not document type\n\n\n\n\n\n","category":"method"},{"location":"nodes/#Nodes","page":"Nodes","title":"Nodes","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"This document describes what each Julia file in src/nodes does during XML parsing, including the crucial phase-specific processing that handles different time periods and XML formats in parliamentary data.","category":"page"},{"location":"nodes/#Phase-System-Overview","page":"Nodes","title":"Phase System Overview","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"The system processes parliamentary transcripts from different time periods with different XML structures:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"PhaseSGML (1981-1997): Earlier SGML-based format \nPhase2011 (1998-2011): Later XML format with different structure\nDefault Phase: Modern format (post-2011)","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Each phase has different XML tag names, processing rules, and output formats.","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"The phase system ensures that parliamentary transcripts from different eras are processed consistently while preserving their unique structural characteristics and historical context.","category":"page"},{"location":"nodes/#Base-Node-Processing-Workflows","page":"Nodes","title":"Base Node Processing Workflows","text":"","category":"section"},{"location":"nodes/#AnswerNode.jl-Answer-Processing","page":"Nodes","title":"AnswerNode.jl - Answer Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Base behavior: Looks for <answer> XML tags in parliamentary transcripts\nContinuation handling: When it finds a \"continue\" element, checks if the parent node is actually an answer node\nValidation: Confirms that the current XML element should be treated as an answer before processing","category":"page"},{"location":"nodes/#AnswersToQuestionsNode.jl-Answer-Collection-Processing","page":"Nodes","title":"AnswersToQuestionsNode.jl - Answer Collection Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <answers.to.questions> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#BusinessNode.jl-Business-Start-Processing","page":"Nodes","title":"BusinessNode.jl - Business Start Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <business.start> tags \nSimple recognition: No content extraction - just recognizes when business proceedings begin","category":"page"},{"location":"nodes/#ChamberNode.jl-Chamber-Transcript-Processing","page":"Nodes","title":"ChamberNode.jl - Chamber Transcript Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Container identification: Identifies <chamber.xscript> elements\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#DebateNode.jl-Debate-Section-Processing","page":"Nodes","title":"DebateNode.jl - Debate Section Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <debate> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins\nTitle extraction: Extracts debate title information from /debateinfo/title path within the debate\nLegacy filtering: Contains commented logic that would filter out debates titled \"BILLS\" (currently disabled)","category":"page"},{"location":"nodes/#DivisionNode.jl-Voting-Division-Processing","page":"Nodes","title":"DivisionNode.jl - Voting Division Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <division> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#FedChamberNode.jl-Federal-Chamber-Processing","page":"Nodes","title":"FedChamberNode.jl - Federal Chamber Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Multi-name support: Identifies both <fedchamb.xscript> (federal chamber) and <maincomm.xscript> (main committee) transcript sections\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#InterTalkNode.jl-Inter-Speaker-Dialogue-Processing","page":"Nodes","title":"InterTalkNode.jl - Inter-Speaker Dialogue Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Content extraction: Looks for <talk.start> elements and extracts text from //talk.text paths\nMissing content handling: If no talk text is found, sets content to a space character\nSpeaker identification: Gets talker information from the parent node in the node tree\nContext validation: Ensures the talk is happening within an interjection section","category":"page"},{"location":"nodes/#InterjectionNode.jl-Interjection-Section-Processing","page":"Nodes","title":"InterjectionNode.jl - Interjection Section Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <interjection> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#PNode.jl-Paragraph-Content-Processing-(Most-Complex,-Highly-Phase-Specific)","page":"Nodes","title":"PNode.jl - Paragraph Content Processing (Most Complex, Highly Phase-Specific)","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Base PNode (Default Phase) - uses <p> tags:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Context identification: Looks for <p> tags within speeches, questions, answers, or business sections\nFirst paragraph detection: Determines if this is the first <p> element under its parent node\nSpeaker extraction: Gets speaker from parent node or searches within paragraph content\nContent processing: Handles item labels, cleans text, builds complete records","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Phase2011 PNode - uses <para> tags:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Different XML structure: Processes <para> tags instead of <p> tags\nExpanded section support: Can appear in more section types including AdjournmentNode, SubdebateNode\nAdvanced first-node detection: \nAlways treats nodes under MotionnospeechNode as first\nChecks for \"talker\" elements two nodes back to determine if it's a first paragraph\nQuote node handling: Special logic where quote nodes act like paragraph containers\nInterTalk integration: Special handling when paragraphs appear within InterTalkNode contexts","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"PhaseSGML PNode - uses <para> tags with SGML-specific features:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"SGML format processing: Handles older SGML-based XML structure with <para> tags\nParent finding logic: Uses special find_p_node_parent() function for complex parent relationships\nFont-based quote detection: Identifies quotes by checking @font-size=\"-=2\" attribute\nNonspeech node detection: Identifies non-speech content in \"NOTICES\" and \"PAPERS\" sections\nSpecial flag handling: Adds nonspeech flag for administrative content without speakers","category":"page"},{"location":"nodes/#QuestionNode.jl-Question-Processing","page":"Nodes","title":"QuestionNode.jl - Question Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Question identification: Identifies <question> XML elements in Q&A sessions\nContinuation support: Handles \"continue\" elements by validating parent node context","category":"page"},{"location":"nodes/#SpeechNode.jl-Speech-Processing","page":"Nodes","title":"SpeechNode.jl - Speech Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Speech recognition: Identifies <speech> XML elements in parliamentary transcripts\nContinuation handling: Processes \"continue\" elements by checking parent node validity","category":"page"},{"location":"nodes/#SubdebateNode.jl-Subdebate-Processing","page":"Nodes","title":"SubdebateNode.jl - Subdebate Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <subdebate.1> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins\nTitle extraction: Gets subdebate title information from /subdebateinfo/title path","category":"page"},{"location":"nodes/#Phase-Specific-Node-Files","page":"Nodes","title":"Phase-Specific Node Files","text":"","category":"section"},{"location":"nodes/#Phase2011-Specific-Nodes-(src/nodes/Phases/Phase2011/nodes/)","page":"Nodes","title":"Phase2011 Specific Nodes (src/nodes/Phases/Phase2011/nodes/)","text":"","category":"section"},{"location":"nodes/#AdjournmentNode.jl-Phase2011-Adjournment-Processing","page":"Nodes","title":"AdjournmentNode.jl - Phase2011 Adjournment Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <adjournment> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins\nPhase-specific structure: Only exists in Phase2011, handles 1998-2011 adjournment format","category":"page"},{"location":"nodes/#InterTalkNode.jl-Phase2011-Inter-Talk-Processing-(Disabled)","page":"Nodes","title":"InterTalkNode.jl - Phase2011 Inter-Talk Processing (Disabled)","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Recognition only: Identifies <talk.start> elements but doesn't process them\nDisabled processing: process_node() and parse_node() functions return nothing\nSimple validation: Just checks if node name matches allowed XPath patterns","category":"page"},{"location":"nodes/#MotionnospeechNode.jl-Phase2011-Motion-Without-Speech","page":"Nodes","title":"MotionnospeechNode.jl - Phase2011 Motion Without Speech","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <motionnospeech> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#PetitionNode.jl-Phase2011-Petition-Processing","page":"Nodes","title":"PetitionNode.jl - Phase2011 Petition Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <petition> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#QuoteNode_.jl-Phase2011-Quote-Processing","page":"Nodes","title":"QuoteNode_.jl - Phase2011 Quote Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <quote> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#PhaseSGML-Specific-Nodes-(src/nodes/Phases/PhaseSGML/nodes/)","page":"Nodes","title":"PhaseSGML Specific Nodes (src/nodes/Phases/PhaseSGML/nodes/)","text":"","category":"section"},{"location":"nodes/#DebateNode.jl-PhaseSGML-Debate-Processing","page":"Nodes","title":"DebateNode.jl - PhaseSGML Debate Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"SGML debate formats: Handles multiple debate names: <debate>, <qwn>, <answer.to.qon>\nTitle extraction: Gets titles from /title path instead of /debateinfo/title","category":"page"},{"location":"nodes/#InterTalkNode.jl-PhaseSGML-Inter-Talk-Processing-(Disabled)","page":"Nodes","title":"InterTalkNode.jl - PhaseSGML Inter-Talk Processing (Disabled)","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Disabled processing: Both process_node() and parse_node() return nothing\nFormat incompatibility: Inter-talk processing is turned off for SGML format","category":"page"},{"location":"nodes/#InterjectionNode.jl-PhaseSGML-Interjection-Processing","page":"Nodes","title":"InterjectionNode.jl - PhaseSGML Interjection Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <interject> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#MotionnospeechNode.jl-PhaseSGML-Motion-Without-Speech","page":"Nodes","title":"MotionnospeechNode.jl - PhaseSGML Motion Without Speech","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <motionnospeech> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#PetitionNode.jl-PhaseSGML-Petition-Processing","page":"Nodes","title":"PetitionNode.jl - PhaseSGML Petition Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Extended petition names: Recognizes both <petition> and <petition.grp> elements\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#QuoteNode_.jl-PhaseSGML-Quote-Processing","page":"Nodes","title":"QuoteNode_.jl - PhaseSGML Quote Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Session marker: Identifies <quote> sections in the XML\nSimple recognition: No content extraction - just recognizes when this section begins","category":"page"},{"location":"nodes/#SubdebateNode.jl-PhaseSGML-Subdebate-Processing","page":"Nodes","title":"SubdebateNode.jl - PhaseSGML Subdebate Processing","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"What it does:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Extended subdebate names: Recognizes both <subdebate.1> and <question.block> as subdebates\nSimple recognition: No content extraction - just recognizes when this section begins\nTitle extraction: Uses /title path instead of /subdebateinfo/title","category":"page"},{"location":"nodes/#Phase-Processing-Summary","page":"Nodes","title":"Phase Processing Summary","text":"","category":"section"},{"location":"nodes/#Phase2011-(1998-2011)-Features:","page":"Nodes","title":"Phase2011 (1998-2011) Features:","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Date Range: 1998-2011 and historical 1901-1980 data\nNew Node Types: AdjournmentNode for session boundaries\nDisabled Features: InterTalkNode processing turned off\nEnhanced Paragraphs: More complex parent-child relationships in PNode\nAdditional Content Types: Petition, quote, motionnospeech support","category":"page"},{"location":"nodes/#PhaseSGML-(1981-1997)-Features:","page":"Nodes","title":"PhaseSGML (1981-1997) Features:","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"SGML Format: Older document structure with different tag names\nExtended Recognition: More debate types (qwn, answer.to.qon)\nDifferent Tags: <interject> instead of <interjection>\nGrouped Content: Petition groups (petition.grp)\nDisabled Features: InterTalkNode processing turned off","category":"page"},{"location":"nodes/#Processing-Differences-Across-Phases:","page":"Nodes","title":"Processing Differences Across Phases:","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Tag Names: Different XML element names for same concepts\nHierarchical Structure: Different parent-child relationships\nContent Detection: Different methods for identifying quotes, speakers, etc.\nFeature Availability: Some processing features disabled in certain phases\nOutput Headers: Different metadata fields in final CSV output\nValidation Rules: Phase-specific logic for determining node types","category":"page"},{"location":"nodes/#Header-Systems-Across-Phases","page":"Nodes","title":"Header Systems Across Phases","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Each phase defines different header configurations for the final CSV output:","category":"page"},{"location":"nodes/#Default-Phase-(GenericPhase)-NodeModule.jl:464","page":"Nodes","title":"Default Phase (GenericPhase) - NodeModule.jl:464","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"question_flag: 1 if within QuestionNode, 0 otherwise\nanswer_flag: 1 if within AnswerNode, 0 otherwise\ninterjection_flag: 1 if within InterjectionNode, 0 otherwise\nspeech_flag: 1 if within SpeechNode, 0 otherwise\nchamber_flag: Chamber type (0=none, 1=chamber, 2=federal, 3=answers)\nname: Speaker name\nname.id: Speaker ID\nelectorate: Speaker's electorate\nparty: Speaker's political party\nrole: Speaker's parliamentary role\npage.no: Page number in original document\ncontent: Text content of the node\nsubdebateinfo: Title of subdebate section\ndebateinfo: Title of debate section\npath: XML path to the node","category":"page"},{"location":"nodes/#Phase2011-(1998-2011)-Phase2011.jl:44","page":"Nodes","title":"Phase2011 (1998-2011) - Phase2011.jl:44","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"All default headers above, plus:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"petition_flag: 1 if within PetitionNode, 0 otherwise\nquote_flag: 1 if within QuoteNode, 0 otherwise\nmotionnospeech_flag: 1 if within MotionnospeechNode, 0 otherwise","category":"page"},{"location":"nodes/#PhaseSGML-(1981-1997)-PhaseSGML.jl:37","page":"Nodes","title":"PhaseSGML (1981-1997) - PhaseSGML.jl:37","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"All Phase2011 headers above, plus:","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"nonspeech: 1 for administrative content in \"NOTICES\"/\"PAPERS\" sections with no speaker, 0 otherwise","category":"page"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"The header system progressively adds more content classification capabilities in later phases while maintaining backward compatibility with core parliamentary data fields.","category":"page"},{"location":"sgml2xml/#Download-the-SGML-files-and-convert-them-to-XML-files","page":"XML download (1981-1997)","title":"Download the SGML files and convert them to XML files","text":"","category":"section"},{"location":"sgml2xml/","page":"XML download (1981-1997)","title":"XML download (1981-1997)","text":"This step downloads the SGML files and converts them into XML files (they are missing from Hansard). ","category":"page"},{"location":"sgml2xml/","page":"XML download (1981-1997)","title":"XML download (1981-1997)","text":"Step one, in your preferred directory, clone the sgml2xml repo with HTTP or SSH:","category":"page"},{"location":"sgml2xml/","page":"XML download (1981-1997)","title":"XML download (1981-1997)","text":"git clone https://github.com/Australian-Parliamentary-Speech/sgml2xml.git","category":"page"},{"location":"sgml2xml/","page":"XML download (1981-1997)","title":"XML download (1981-1997)","text":"Go into the directory","category":"page"},{"location":"sgml2xml/","page":"XML download (1981-1997)","title":"XML download (1981-1997)","text":"cd sgml2xml","category":"page"},{"location":"sgml2xml/","page":"XML download (1981-1997)","title":"XML download (1981-1997)","text":"In the directory, run:","category":"page"},{"location":"sgml2xml/","page":"XML download (1981-1997)","title":"XML download (1981-1997)","text":"./run house","category":"page"},{"location":"sgml2xml/","page":"XML download (1981-1997)","title":"XML download (1981-1997)","text":"or ","category":"page"},{"location":"sgml2xml/","page":"XML download (1981-1997)","title":"XML download (1981-1997)","text":"./run senate","category":"page"},{"location":"sgml2xml/","page":"XML download (1981-1997)","title":"XML download (1981-1997)","text":"The XML files should be in the directory senate_xmls or house_xmls","category":"page"},{"location":"sgml2xml/#required-file:","page":"XML download (1981-1997)","title":"required file:","text":"","category":"section"},{"location":"sgml2xml/","page":"XML download (1981-1997)","title":"XML download (1981-1997)","text":"hansard.dtd (converts sgml to xml) HansardSGML.csv (all the links required) sgml2xml.jl download_utils.jl (hidden file) run (bash script)","category":"page"},{"location":"download/#Download-the-XML-files","page":"XML download","title":"Download the XML files","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"This step downloads all the available XML files from the Hansard directly","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"Step one, in your preferred directory, clone the Download repo with HTTP or SSH:","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"git clone https://github.com/Australian-Parliamentary-Speech/Download.git","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"Go into the directory:","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"cd Download","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"In the directory, run:","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"./run house","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"or","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"./run senate","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"The XML files should be in the directory sitemap_xmls_senate or sitemap_xmls_house.","category":"page"},{"location":"download/#Required-files","page":"XML download","title":"Required files","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"XML_download_method1.jl","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"utils.jl","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"download_utils.jl ","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"run (bash file)","category":"page"},{"location":"download/#logfile","page":"XML download","title":"logfile","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"The logfiles are in sitemap_logfiles/. It contains information on how many links in total were detected (to compare with the parlinfo website) and how many missing were updated from this run.","category":"page"},{"location":"download/#To-update-the-download","page":"XML download","title":"To update the download","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"The same command above can be used again to update the XMLs: In the directory, run:","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"./run house","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"or","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"./run senate","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"The program will detect what already exists and update what is not there. For this to work, please do not delete any folders generated from the last run. An error will occur if you run the program twice in a day. This is to prevent over-writing. ","category":"page"},{"location":"download/#Implementation-details","page":"XML download","title":"Implementation details","text":"","category":"section"},{"location":"download/#Step-1:-download-the-first-layer-XML-pages","page":"XML download","title":"Step 1: download the first layer XML pages","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"The first step downloads each XML page provided by the first sitemap. Each of these pages would contain a list of HTML links. This step will run every time regardless if previous runs were conducted. The reason for that is this first link gets updated with overwritten names everytime. ","category":"page"},{"location":"download/#Step-2:-extract-all-the-html-links","page":"XML download","title":"Step 2: extract all the html links","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"The second step extracts all the HTML links from the XML files downloaded in step 1 into a csv file sitemap_html_step2_<dateofcreation>.csv.","category":"page"},{"location":"download/#Step-3:-compare-the-current-csv-with-any-existing-file","page":"XML download","title":"Step 3: compare the current csv with any existing file","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"This step is run if any other csv from the previous run is detected. It compares the csv generated in step 2 and the previous csv and generate a csv file containing the HTML links in current run and not in the previous run. The resulting file would be named sitemap_html_step2_missing.csv.","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"If no existing previous run is detected, this step will not run.","category":"page"},{"location":"download/#Step-4:-download-the-html-files","page":"XML download","title":"Step 4: download the html files","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"This step downloads all the HTML files either from the missing ones or the entire csv from step 2, depending on if previous run was detected. The html files will be downloaded to directory sitemap_htmls_step4_<dateofcreation>. If any file has failed t download, the links would appear in the log file in directory sitemap_logfiles/.","category":"page"},{"location":"download/#Step-5:-extract-the-xml-links","page":"XML download","title":"Step 5: extract the xml links","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"This step extracts all the missing xml links (or the complete set) into a csv called site_map_xml_step5_<dateofcreation>.csv","category":"page"},{"location":"download/#Step-6:-download-the-xml-files","page":"XML download","title":"Step 6: download the xml files","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"This step downloads the xml files from the links provided in step 5 into sitemap_xmls/.","category":"page"},{"location":"download/#Step-7:-add-the-new-xml-links-into-the-existing-file-and-remove-the-old-run.","page":"XML download","title":"Step 7: add the new xml links into the existing file and remove the old run.","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"This step just cleans up the old files and gets ready for the next run. The total number of links detected will also show up in the logfile to compare with the result from https://parlinfo.aph.gov.au/parlInfo/search/summary/summary.w3p;adv%3Dyes;orderBy%3D_fragment_number,doc_date-rev;query%3DDataset%3Ahansardr,hansardr80;resCount%3DDefault. It is recommened to delete some of the sitemap_htmls_step4_<dateofcreation> so they don't stack up too much. But it is not necessary. ","category":"page"},{"location":"#ParlinfoSpeechScraper","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"","category":"section"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"This project is divided into three parts, which correspond to three repos: Download, sgml2xml, and Scraper. The repo Download downloads the XML files directly from the Parlinfo roadmap. The repo sgml2xml downloads the sgml files and convert them into XML files. This is for the years where the XML files are missing. Finally Scraper parses the XML files and produces CSV files that contain all the speech information.  ","category":"page"},{"location":"#Quick-start","page":"ParlinfoSpeechScraper","title":"Quick start","text":"","category":"section"},{"location":"#Windows-users","page":"ParlinfoSpeechScraper","title":"Windows users","text":"","category":"section"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"All commands here work natively for Mac and Linux users.","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"Since this project uses bash scripts (e.g., ./run house), Windows users need a bash environment to run these commands. One option is to install Git Windows to create a bash shell environment. Once installed, right click \"Git Bash Here\" and run bash commands there. ","category":"page"},{"location":"#Install-Julia","page":"ParlinfoSpeechScraper","title":"Install Julia","text":"","category":"section"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"To run the package, Julia needs to be installed. For help see https://julialang.org/install/","category":"page"},{"location":"#Download-the-XML-files","page":"ParlinfoSpeechScraper","title":"Download the XML files","text":"","category":"section"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"Step one, in your preferred directory, for example HansardScraper/, clone the Download repo with HTTP or SSH:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"cd HansardScraper","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"git clone https://github.com/Australian-Parliamentary-Speech/Download.git","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"Go into the directory:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"cd Download","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"In the directory (in a bash environment), run:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"./run house","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"or","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"./run senate","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"The XML files should be in the directory sitemapxmlssenate or sitemapxmlshouse.","category":"page"},{"location":"#Download-the-SGML-files-and-convert-them-to-XML-files","page":"ParlinfoSpeechScraper","title":"Download the SGML files and convert them to XML files","text":"","category":"section"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"Step one, in your preferred directory, for example HansardScraper/, clone the sgml2xml repo with HTTP or SSH:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"cd HansardScraper","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"git clone https://github.com/Australian-Parliamentary-Speech/sgml2xml.git","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"Go into the directory","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"cd sgml2xml","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"In the directory (in a bash environment), run:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"./run house","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"or ","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"./run senate","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"The XML files should be in the directory senatexmls or housexmls","category":"page"},{"location":"#Parsing","page":"ParlinfoSpeechScraper","title":"Parsing","text":"","category":"section"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"Step one, in your preferred directory, for example HansardScraper/, clone this repo with HTTP or SSH:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"cd HansardScraper","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"git clone https://github.com/Australian-Parliamentary-Speech/Scraper.git","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"Go into the directory:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"cd Scraper","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"You would have to copy all the downloaded XML files into Inputs/hansard/, first make the directory:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"For Senate:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"mkdir -p Inputs/hansard/senate_xmls","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"mv -f ../sgml2xml/senate_xmls/* Inputs/hansard/senate_xmls","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"mv -f ../Download/sitemap_xmls_senate/* Inputs/hansard/senate_xmls","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"For House:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"mkdir -p Inputs/hansard/house_xmls","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"mv -f ../sgml2xml/house_xmls/* Inputs/hansard/house_xmls","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"mv -f ../Download/sitemap_xmls_house/* Inputs/hansard/house_xmls","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"In the directory, run:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"For Senate: ","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"./run Inputs/hansard/senate.toml","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"For House:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"./run Inputs/hansard/house.toml","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"The output file will be in Outputs/SenateCSV or Outputs/HouseCSV","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"To run different year ranges or a specific year,senate.toml or house.toml file needs to be editted (details see here).","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"For Windows users:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"For Senate:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"mkdir Inputs\\hansard\\senate_xmls","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"move /Y ..\\sgml2xml\\senate_xmls\\* Inputs\\hansard\\senate_xmls\\","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"move /Y ..\\Download\\sitemap_xmls_senate\\* Inputs\\hansard\\senate_xmls\\","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"In the directory (in a bash environment), run:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"./run Inputs/hansard/senate.toml","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"For House:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"mkdir Inputs\\hansard\\house_xmls","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"move /Y ..\\sgml2xml\\house_xmls\\* Inputs\\hansard\\house_xmls\\","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"move /Y ..\\Download\\sitemap_xmls_house\\* Inputs\\hansard\\house_xmls\\","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"In the directory (in a bash environment), run:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"./run Inputs/hansard/house.toml","category":"page"},{"location":"#To-inspect-how-each-node-is-processed","page":"ParlinfoSpeechScraper","title":"To inspect how each node is processed","text":"","category":"section"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"In the directory src/nodes, all the information regarding how each node is processed is stored in the corresponding file. For example, how nodes with nodename \"p\" would be stored in PNode.jl. The detailed documentation can be accessed in both docs/build/nodes/index.html or the docstrings in each function.","category":"page"},{"location":"#Overall-structure","page":"ParlinfoSpeechScraper","title":"Overall structure","text":"","category":"section"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"The documentation page is arranged as follows: Normal usage in terms of inputs and outputs is explained in Usage, and more advanced interaction that includes adding a node or phase type is explained in Advanced usage. The current implementation of different nodes in all phases is shown in Nodes. Function references shows all the docstrings in the program.","category":"page"}]
}
