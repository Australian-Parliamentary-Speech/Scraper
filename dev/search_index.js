var documenterSearchIndex = {"docs":
[{"location":"summaries/#Summaries","page":"Summaries","title":"Summaries","text":"","category":"section"},{"location":"summaries/","page":"Summaries","title":"Summaries","text":"This page contains some summary statistics we have calculated for our scraping result.","category":"page"},{"location":"summaries/#Number-of-sitting-days-detected-for-each-year","page":"Summaries","title":"Number of sitting days detected for each year","text":"","category":"section"},{"location":"summaries/","page":"Summaries","title":"Summaries","text":"   using CSV, DataFrames\n   using Latexify\n   using Dates\n   using ParlinfoSpeechScraper\n\n   current_year = year(today())\n\n   parent_dir = pathof(ParlinfoSpeechScraper)\n   dir_ = joinpath(dirname(dirname(parent_dir)),\"test\")\n   df = CSV.read(joinpath(dir_,\"summary_all_dates.csv\"),DataFrame;header=false)\n    \n   years = collect(1901:current_year)\n   counts = [0 for i in 1:length(years)]\n   n = 1900\n   for row in eachrow(df)\n        year = row[1]\n        count_ = 0\n        for ele in row\n            if ismissing(ele)\n                count_ += 1\n            end\n        end\n        counts[year-n] = count_\n   end\n   M = vcat(years',counts')\n   sides = [\"Year\",\"Number of sitting days detected\"]\n   mdtable(M,latex=false,side=sides)","category":"page"},{"location":"summaries/#The-speaker-coverage","page":"Summaries","title":"The speaker coverage","text":"","category":"section"},{"location":"summaries/","page":"Summaries","title":"Summaries","text":"   using CSV, DataFrames\n   using Latexify\n   using ParlinfoSpeechScraper\n   using Dates\n\n   current_year = year(today())\n\n   parent_dir = pathof(ParlinfoSpeechScraper)\n   dir_ = joinpath(dirname(dirname(parent_dir)),\"test\")\n   df = CSV.read(joinpath(dir_,\"summary_speaker_coverage.csv\"),DataFrame;header=false)\n   M = Matrix(df)\n   M[:, 1] = Int.(M[:, 1])\n   sides = [\"Year\",\"No. speaker detected\",\"No. missing speakers\",\"Detection ratio\"]\n   mdtable(M',latex=false,side=sides)\n ","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here we start with the description of the user interface regarding inputs and outputs. Details about some structurally important functions are listed after.","category":"page"},{"location":"usage/#Inputs","page":"Usage","title":"Inputs","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The input xml files live in the directory src/Inputs/, and specifically where they live is specified in the toml file. For example, as currently stated in Inputs/hansard/hansard.toml, the xmls live in src/Inputs/hansard/xmls. You can define your own toml and your own directory of where the xmls live. To run the program, head to the src/ directory and run:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"./run Inputs/hansard/hansard.toml","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"or ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"./run <insert your toml file>","category":"page"},{"location":"usage/#Input-toml-file","page":"Usage","title":"Input toml file","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The input toml file allows the user to select options for the run. The output directory, the year range, whether the first step of the process is done and whether edit is preferred are the options that the user can edit. In terms of what files the program runs, we have two modes available when running the program. It can run one xml file or a directory of xml files. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For a single xml file:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"[ global ]\n    output_path = \"../../Outputs/hansard\"\n\n[[ XML ]]\n    filename = \"xmls/2008/2008-12-01.xml\"\n\n[ general_options ]\n    csv_exist = false\n    edit = true\n    year = [1900,2024]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Note that if the date for the single xml is out of range from the year defined, the program might not run.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For a directory of xmls:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"[ global ]\n    output_path = \"../../Outputs/hansard\"\n\n[[ XML_DIR ]]\n    path = \"xmls\"\n\n[ general_options ]\n    csv_exist = false\n    edit = true\n    year = [1900,2024]","category":"page"},{"location":"usage/#Outputs","page":"Usage","title":"Outputs","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Where the output files go can be edited by the user in the toml file shown above. Currently, they are stored in Outputs/hansard.","category":"page"},{"location":"advusage/#Advanced-usage","page":"Advanced Usage","title":"Advanced usage","text":"","category":"section"},{"location":"advusage/#How-to-introduce-a-new-node-to-the-algorithm","page":"Advanced Usage","title":"How to introduce a new node to the algorithm","text":"","category":"section"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"Here is a template for adding a new node to the program in the default phase. If a node is needed for a particular phase, simply exchange the path from \"nodes/\" to \"nodes/Phases/<yourphase>/nodes/\". ","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"export ExampleNode\n\n#defining a new abstract type for the node\nabstract type ExampleNode{P} <: AbstractNode{P} end\n\n#what are the xpaths associated with the node\nfunction get_xpaths(::Type{<:ExampleNode})\n    return [\"xpath1\",\"xpath2\"]\nend","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"The code above provides a starting point for adding a new node. The algorithm will now recognise the new nodes with xpath1 and xpath2 as nodenames. The default function process_node is defined in NodeModule.jl. If a different process_node function is preferred (same goes with any other already defined functions), a new process_node can be defined in the present file in this way:","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"function process_node(node::Node{<:ExampleNode},node_tree)\n    <insertyourcodehere>\nend","category":"page"},{"location":"advusage/#How-to-introduce-a-new-phase-into-the-algorithm","page":"Advanced Usage","title":"How to introduce a new phase into the algorithm","text":"","category":"section"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"In the directory nodes/Phases/, make a new directory\"Phases/ExamplePhase/\". Make a new directory \"Phases/ExamplePhase/nodes/\" to harbour new node definitions. Create a new phase julia file in the ExamplePhase directory PhaseExample.jl. A starting file might look at this:","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"\nabstract type PhaseExample <: AbstractPhase end\n\n# Get Phase Node Overrides\nphase_node_path = joinpath(@__DIR__, \"nodes\")\n\nfor path in readdir(phase_node_path, join=true)\n    if isfile(path)\n        include(path)\n    end\nend\n\n# define which phase is this new phase defined over.\ndate_to_float converts a date year,month,day to float. For example, if the range of the phase goes from 1st Jan 1901 tp 6th Dec 1901:\nupperbound = date_to_float(1901,12,6)\nlowerbound = date_to_float(1901,1,1)\ndate_to_phase[(lowerbound,upperbound)] = PhaseExample","category":"page"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"You can then add any new definition for node processing in the \"Phases/ExamplePhase/nodes\" directory.","category":"page"},{"location":"advusage/#How-to-add-a-new-flag","page":"Advanced Usage","title":"How to add a new flag","text":"","category":"section"},{"location":"advusage/","page":"Advanced Usage","title":"Advanced Usage","text":"In order to add a new flag, or a new column of content, you would only need to interact with two functions: define_flags and define_headers. The dictionary that contains all information gets passed around and content gets added into it as the parsing goes on. The headers_dict sets all headers to \"N/A\" to start with and they get overwritten during running. ","category":"page"},{"location":"functionreference/#Function-references","page":"Function references","title":"Function references","text":"","category":"section"},{"location":"functionreference/#ParlinfoSpeechScraper","page":"Function references","title":"ParlinfoSpeechScraper","text":"","category":"section"},{"location":"functionreference/#ParlinfoSpeechScraper.get_args-Tuple{}","page":"Function references","title":"ParlinfoSpeechScraper.get_args","text":"get_args()\n\nParse command-line arguments\n\nThis function sets up and parses command-line arguments using the ArgParse package. It defines the arguments that can be passed to the script, including options for verbosity and input file path.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.main-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.main","text":"main(toml_path, verbose)\n\nMain function to initialize and execute the Parlinfo Speech Scraper\n\nThis function initializes the input configuration from a TOML file specified by toml_path with optional verbosity controlled by verbose. It then runs the ParlinfoSpeechScraper using the configuration.\n\nInputs:\n\ntoml_path: Path to the TOML configuration file.\nverbose: Boolean flag indicating if logging verbosity should be increased.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.main-Tuple{}","page":"Function references","title":"ParlinfoSpeechScraper.main","text":"main()\n\nMain function to process command-line arguments and run the program\n\nThis function serves as the entry point of the script. It processes command-line arguments, retrieves the necessary parameters, and calls the main processing function with those parameters.\n\nInputs: None\n\nArguments:\n\nargs: A dictionary containing the parsed command-line arguments.\nargs[\"input\"]: Path to the input TOML file.\nargs[\"verbose\"]: Boolean flag indicating if logging verbosity should be increased.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#RunModule","page":"Function references","title":"RunModule","text":"","category":"section"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.get_date-Tuple{Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.get_date","text":"get_date(fn)\n\nGet the date from the xml file\n\nInputs:\n\nfn: the file directory for the xml file\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.recurse","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.recurse","text":"recurse(soup, date, PhaseType, xmlnode, io, index=1, depth=0, maxdepth=0, node_tree=Vector{Node}())\n\nRecursively process XML nodes and write data to output\n\nThis function recursively processes XML nodes, extracts relevant data, and writes it to an output stream. It handles node types, depth limitations, and maintains a tree of processed nodes.\n\nInputs:\n\nsoup: The parsed XML document.\ndate: The date associated with the XML document.\nPhaseType: The phase type determined from the date.\nxml_node: The current XML node being processed.\nio: The output stream where data is written.\nindex (optional): The index of the current node (default is 1).\ndepth (optional): The current depth of recursion (default is 0).\nmax_depth (optional): The maximum depth for recursion (default is 0, meaning no limit).\nnode_tree (optional): A vector maintaining the tree of nodes (default is an empty vector).\n\n\n\n\n\n","category":"function"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.run_ParlinfoSpeechScraper-Tuple{Dict{String, Any}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.run_ParlinfoSpeechScraper","text":"run_ParlinfoSpeechScraper(toml::Dict{String, Any})\n\nThis function processes XML files for parliamentary speeches according to the configuration specified in the provided TOML dictionary. It reads XML file paths, processes each XML file, and outputs the results to a specified directory.\n\nInputs:\n\ntoml: A dictionary containing configuration options for the scraper.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.run_xml-NTuple{4, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.run_xml","text":"run_xml(fn, output_path, csv_exist, edit_funcs)\n\nProcess and save XML data to CSV\n\nThis function processes an XML file, extracts relevant data, and saves it to a CSV file. If specified, it also edits the CSV file after creation.\n\nInputs:\n\nfn: The file path for the XML file.\noutput_path: The directory where the processed CSV file will be saved.\ncsv_exist: Boolean flag indicating if a CSV file already exists.\nedit_funcs: list of edit functions\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#XMLModule","page":"Function references","title":"XMLModule","text":"","category":"section"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.edit_main-Tuple{Any, Editor}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.edit_main","text":"func_list: a list of function names as string editor: a struct with two parameters\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.edit_set_up-Tuple{Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.edit_set_up","text":"editsetup(headers)\n\nSets up a dictionary mapping each element in headers to its corresponding index.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.find_all_child_speeches-NTuple{4, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.find_all_child_speeches","text":"function findallchildspeeches(rowno,rows,headertonum,is_written)\n\nFind all the speeches that belong to a single talker \n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.find_all_flags-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.find_all_flags","text":"get all flags except chamber flag\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.EditModule.free_node-NTuple{6, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.EditModule.free_node","text":"if it is free flowing, check if it is same debate and add it to the previous one\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#NodeModule","page":"Function references","title":"NodeModule","text":"","category":"section"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.detect_phase-Tuple{Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.detect_phase","text":"detect_phase(date)\n\nInputs:\n\ndate: A floating-point number representing the date to detect the phase for.\n\nReturns:\n\nThe phase associated with the provided date, or AbstractPhase if no specific phase is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_all_subtypes","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_all_subtypes","text":"get_all_subtypes(type, st=[])\n\nGet every subtype of the provided type parameter.\n\nInputs:\n\ntype: the provided type\n\n\n\n\n\n","category":"function"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_name-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_name","text":"reversefindfirstnodename(node_tree, names)\n\nInputs:\n\nnode_tree: A vector representing a tree of nodes to search in reverse order.\nnames: A collection of node names to search for.\n\nReturns:\n\nThe first node from node_tree in reverse order whose name is in the names collection, or nothing if no such node is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_not_name-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_not_name","text":"reversfindfirstnodenotname(nodetree, names)\n\nInputs:\n\nnode_tree: A vector representing a tree of nodes to search in reverse order.\nnames: A collection of node names. The function searches for the first node from node_tree in reverse order whose name is not in this collection.\n\nReturns:\n\nThe first node from node_tree in reverse order whose name is not in the names collection, or nothing if no such node is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_talker_from_parent-Tuple{Node, Node}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_talker_from_parent","text":"gettalkerfromparent(node::Node,parentnode::Node)\n\nIt finds the speaker information from the parent node\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.detect_node_type-NTuple{5, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.detect_node_type","text":"detectnodetype(node, node_tree, date, soup, PhaseType)\n\ndefault setting:\n\nInputs:\n\nnode: The XML node to determine the type for.\nnode_tree: A vector representing a tree of nodes\ndate: The date associated with the node.\nsoup: The root node.\nPhaseType: The phase type determined from the date of XML.\n\nReturns:\n\nThe detected node type (NodeType).\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.parse_node-Tuple{Node, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.parse_node","text":"parsenode(node::Node, nodetree, io)\n\ndefault setting:\n\nInputs:\n\nnode: xml node of Node struct\nnode_tree: A vector representing a tree of nodes for context.\nio: The output stream where processed data is written.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.process_node","text":"processnode(node::Node, nodetree)\n\ndefault setting:\n\nInputs:\n\nnode: xml node of Node struct\nnode_tree: A vector representing a tree of nodes for context.\n\nNotes:\n\nThis function is typically invoked when no specific processing behavior is defined for the NodeType associated with node.\nUsers may customize or define specific behaviors for different NodeType instances within their implementation.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{<:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode}, Type{<:AbstractPhase}, Any, Vararg{Any}}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype","text":"isnodetype(node, nodetree, nodetype::Type{<:AbstractNode}, phase::Type{<:AbstractPhase}, soup, args...; kwargs...)\n\ndefault setting:\n\nInputs:\n\nnode: The XML node to evaluate.\nnode_tree: A vector representing a tree of nodes for context.\nnodetype: A subtype of AbstractNode representing the type of node to check against.\nphase: A subtype of AbstractPhase representing the phase associated with the node.\nsoup: The root node.\nargs...: Optional additional arguments.\nkwargs...: Optional keyword arguments.\n\nReturns:\n\ntrue if the name of node is found in the allowed names associated with nodetype for the given phase, false otherwise.\n\nNotes: More specific detection method for nodes is defined in nodes/\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Union{Tuple{Type{<:N}}, Tuple{N}} where N<:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{<:N}) where {N <: AbstractNode}\n\nThis function serves as a placeholder and returns an empty array, which is meant to provide the nodenames allowed for each type. For example, speech nodes can have names \"speech\" or \"continue\". \n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.find_section_title-Tuple{Any, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_section_title","text":"findsectiontitle(nodetree, soup, sectiontype)\n\nInputs:\n\nnode: The XML node from which to extract the section title.\nnode_tree: A vector representing a tree of nodes for context.\nsoup: The root node of the XML document.\nsection_type: The nodenames of the types of section nodes where the title is wanted. For example, \"speech\".\n\nReturns:\n\nThe title of the specified section_type found within the XML document, or \"N/A\" if not found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.find_chamber-Tuple{Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_chamber","text":"findchamber(node, nodetree)\n\nIdentifies the type of chamber associated with the given XML node.\n\nInputs:\n\nnode: The XML node \nnode_tree: A vector representing a tree of nodes for context.\n\nReturns:\n\nAn integer indicating the chamber type:\n2 for a federal chamber (FedChamberNode).\n1 for a chamber (ChamberNode).\n0 if no chamber node is found.\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.define_flags-Tuple{Node, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.define_flags","text":"defineflags(node::Node{<:AbstractNode{<:AbstractPhase}}, nodetree)\n\nGenerates flags based on the characteristics of the given node.\n\nInputs:\n\nnode: A Node struct.\nnode_tree: A vector representing a tree of nodes for context.\n\nReturns:\n\nAn array of flags indicating characteristics of node\n\n\n\n\n\n","category":"method"},{"location":"functionreference/#ParlinfoSpeechScraper.RunModule.NodeModule.write_test_xml-Tuple{Any, Any, Any}","page":"Function references","title":"ParlinfoSpeechScraper.RunModule.NodeModule.write_test_xml","text":"Writes the test xmls for all edge cases: it cannot handle dummy parent as root itself â€“ soup is getting passed and not document type\n\n\n\n\n\n","category":"method"},{"location":"nodes/#Nodes","page":"Nodes","title":"Nodes","text":"","category":"section"},{"location":"nodes/#2012-2024-(default)","page":"Nodes","title":"2012-2024 (default)","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Here we show how the nodes are defined for different years.","category":"page"},{"location":"nodes/#PNode","page":"Nodes","title":"PNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"p\"","category":"page"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{<:PNode}}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{<:PNode})\n\nFind what the p_node is called in xml for default\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node{<:PNode}, Any}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.process_node","text":"processnode(node::Node{<:PNode},nodetree)\n\nIf no particular phase is specified, this default version of process node is run. \n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type-Tuple{Node{<:PNode}, Any, Any, Any}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type","text":"isfirstnodetype(node::Node{<:PNode},parentnode,allowednames,nodetree)\n\nThis default function detects if the pnode detected is the first pnode under a parent node. The reason for this is that if the p_node is not the first node, there are alternative checks to see if the talker has changed since the first one.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.find_talker_in_p-Tuple{Node{<:PNode}}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_talker_in_p","text":"findtalkerinp(pnode)\n\nIf the pnode is not the first pnode, we check if there is a talker inside the p_node.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.p_with_a_as_parent-Tuple{Any}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.p_with_a_as_parent","text":"pwithaasparent(p_node)\n\nIf no talker is found for the first node, we look for a \"a\" as parentnode.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{<:PNode}}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{<:PNode})\n\nIn which sections are the p_node wanted as default.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{<:PNode}, Type{<:AbstractPhase}, Any, Vararg{Any}}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype","text":"isnodetype(node, nodetree, nodetype::Type{<:PNode},phase::Type{<:AbstractPhase},soup, args...; kwargs...) \n\nThis function detects whether the given xml node is PNode. This function takes the phase into account aswell.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.parse_node-Tuple{Node{<:PNode}, Any, Any}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.parse_node","text":"parsenode(node::Node{<:PNode},nodetree,io)\n\nThe default function to take a p_node and write to the csv\n\n\n\n\n\n","category":"method"},{"location":"nodes/#InterTalkNode","page":"Nodes","title":"InterTalkNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"talk.start\"","category":"page"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{<:InterTalkNode}}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{<:InterTalkNode})\n\nThe default setting for what nodenames are allowed for intertalknode.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node{<:InterTalkNode}, Any}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.process_node","text":"processnode(node::Node{<:InterTalkNode},nodetree)\n\nThe default setting for processing intertalknodes.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{<:InterTalkNode}}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{<:InterTalkNode})\n\nThe default setting for the sections where intertalknodes are processed\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{<:InterTalkNode}, Type{<:AbstractPhase}, Any, Vararg{Any}}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype","text":"isnodetype(node, nodetree, nodetype::Type{<:InterTalkNode},phase::Type{<:AbstractPhase},soup, args...; kwargs...) \n\nThis function checks if the given xml node is of nodetype InterTalkNode\n\n\n\n\n\n","category":"method"},{"location":"nodes/#Placeholder-nodes","page":"Nodes","title":"Placeholder nodes","text":"","category":"section"},{"location":"nodes/#AnswerNode","page":"Nodes","title":"AnswerNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"answer\"","category":"page"},{"location":"nodes/#BusinessNode","page":"Nodes","title":"BusinessNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"business.start\"","category":"page"},{"location":"nodes/#ChamberNode","page":"Nodes","title":"ChamberNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"chamber.xscript\"","category":"page"},{"location":"nodes/#FedChamberNode","page":"Nodes","title":"FedChamberNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"fedchamb.xscript\", \"maincomm.xscript\"","category":"page"},{"location":"nodes/#DebateNode","page":"Nodes","title":"DebateNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"debate\"","category":"page"},{"location":"nodes/#DivisionNode","page":"Nodes","title":"DivisionNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"division\"","category":"page"},{"location":"nodes/#InterjectionNode","page":"Nodes","title":"InterjectionNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"interjection\", \"continue\"","category":"page"},{"location":"nodes/#QuestionNode","page":"Nodes","title":"QuestionNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"question\"","category":"page"},{"location":"nodes/#SpeechNode","page":"Nodes","title":"SpeechNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"speech\", \"question\", \"answer\"","category":"page"},{"location":"nodes/#SubdebateNode","page":"Nodes","title":"SubdebateNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"subdebate.1\"","category":"page"},{"location":"nodes/#before-April-2011-(exclude-1981-1997)","page":"Nodes","title":"before April 2011 (exclude 1981-1997)","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"Phase information:","category":"page"},{"location":"nodes/#Phase2011","page":"Nodes","title":"Phase2011","text":"","category":"section"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.define_flags-Tuple{Node{<:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}, Any, Any}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.define_flags","text":"defineflags(node::Node{<:AbstractNode{Phase2011}},parentnode,node_tree)\n\nAdded petition and quote nodes on top of the previous flags\n\n\n\n\n\n","category":"method"},{"location":"nodes/#PNode-2","page":"Nodes","title":"PNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"para\"","category":"page"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{PNode{Phase2011}})\n\n\"para\" as accepted xpaths for PNode.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{PNode{Phase2011}})\n\nAllowed sections for PNodes.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type-Tuple{Node{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}, Any, Any, Any}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type","text":"isfirstnodetype(node::Node{PNode{Phase2011}},parentnode,allowednames,nodetree)\n\nA different method to detect if the pnode is the first pnode for this phase\n\n\n\n\n\n","category":"method"},{"location":"nodes/#Placeholder-nodes-2","page":"Nodes","title":"Placeholder nodes","text":"","category":"section"},{"location":"nodes/#MotionnospeechNode","page":"Nodes","title":"MotionnospeechNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"motionnospeech\"","category":"page"},{"location":"nodes/#PetitionNode","page":"Nodes","title":"PetitionNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"petition\"","category":"page"},{"location":"nodes/#QuoteNode_","page":"Nodes","title":"QuoteNode_","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"quote\"","category":"page"},{"location":"nodes/#1981-1997-(SGML)","page":"Nodes","title":"1981-1997 (SGML)","text":"","category":"section"},{"location":"nodes/#PNode-3","page":"Nodes","title":"PNode","text":"","category":"section"},{"location":"nodes/","page":"Nodes","title":"Nodes","text":"xpaths: \"para\"","category":"page"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.PhaseSGML}}}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{PNode{PhaseSGML}})\n\n\"para\" as accepted xpaths for PNode.\n\n\n\n\n\n","category":"method"},{"location":"nodes/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.PhaseSGML}}}","page":"Nodes","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{PNode{PhaseSGML}})\n\nAllowed sections for PNodes.\n\n\n\n\n\n","category":"method"},{"location":"sgml2xml/#Downloading-the-XML-files-from-1981-1996","page":"XML download (1981-1996)","title":"Downloading the XML files from 1981-1996","text":"","category":"section"},{"location":"sgml2xml/","page":"XML download (1981-1996)","title":"XML download (1981-1996)","text":"The XML files from 1981-1997 are missing from the sitemap provided on Parlinfo website. From 1981-1996 sgml files were downloaded and then converted into xml files.","category":"page"},{"location":"download/#Downloading-the-XML-files","page":"XML download","title":"Downloading the XML files","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"We use the sitemap provided by https://parlinfo.aph.gov.au/sitemap/sitemapindex.xml to download the XML files. The sitemap contains a list of XML links which then provide with the html pages where the links for the debate XML pages were provided. Here we give a brief overlook on the steps the program takes to download the XMLs and the information in the logfile if anything goes wrong. All csv files will be stored in sitemap_inter_csvs/. All files live in ParlinfoSpeechScraper/Download/.","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"To update or run for the first time, head to the Download/ directory and run","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"julia XML_Download_method1.jl","category":"page"},{"location":"download/#logfile","page":"XML download","title":"logfile","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"The logfiles are in sitemap_logfiles/. It contains information on how many links in total were detected (to compare with the parlinfo website) and how many missing were updated from this run.","category":"page"},{"location":"download/#Step-1:-download-the-first-layer-XML-pages","page":"XML download","title":"Step 1: download the first layer XML pages","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"The first step downloads each XML page provided by the first sitemap. Each of these pages would contain a list of HTML links. This step will run every time regardless if previous runs were conducted. The reason for that is this first link gets updated with overwritten names everytime. ","category":"page"},{"location":"download/#Step-2:-extract-all-the-html-links","page":"XML download","title":"Step 2: extract all the html links","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"The second step extracts all the HTML links from the XML files downloaded in step 1 into a csv file sitemap_html_step2_<dateofcreation>.csv.","category":"page"},{"location":"download/#Step-3:-compare-the-current-csv-with-any-existing-file","page":"XML download","title":"Step 3: compare the current csv with any existing file","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"This step is run if any other csv from the previous run is detected. It compares the csv generated in step 2 and the previous csv and generate a csv file containing the HTML links in current run and not in the previous run. The resulting file would be named sitemap_html_step2_missing.csv.","category":"page"},{"location":"download/","page":"XML download","title":"XML download","text":"If no existing previous run is detected, this step will not run.","category":"page"},{"location":"download/#Step-4:-download-the-html-files","page":"XML download","title":"Step 4: download the html files","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"This step downloads all the HTML files either from the missing ones or the entire csv from step 2, depending on if previous run was detected. The html files will be downloaded to directory sitemap_htmls_step4_<dateofcreation>. If any file has failed t download, the links would appear in the log file in directory sitemap_logfiles/.","category":"page"},{"location":"download/#Step-5:-extract-the-xml-links","page":"XML download","title":"Step 5: extract the xml links","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"This step extracts all the missing xml links (or the complete set) into a csv called site_map_xml_step5_<dateofcreation>.csv","category":"page"},{"location":"download/#Step-6:-download-the-xml-files","page":"XML download","title":"Step 6: download the xml files","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"This step downloads the xml files from the links provided in step 5 into sitemap_xmls/.","category":"page"},{"location":"download/#Step-7:-add-the-new-xml-links-into-the-existing-file-and-remove-the-old-run.","page":"XML download","title":"Step 7: add the new xml links into the existing file and remove the old run.","text":"","category":"section"},{"location":"download/","page":"XML download","title":"XML download","text":"This step just cleans up the old files and gets ready for the next run. The total number of links detected will also show up in the logfile to compare with the result from https://parlinfo.aph.gov.au/parlInfo/search/summary/summary.w3p;adv%3Dyes;orderBy%3D_fragment_number,doc_date-rev;query%3DDataset%3Ahansardr,hansardr80;resCount%3DDefault. It is recommened to delete some of the sitemap_htmls_step4_<dateofcreation> so they don't stack up too much. But it is not necessary. ","category":"page"},{"location":"#ParlinfoSpeechScraper","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"","category":"section"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"The ParlinfoSpeechScraper processes the xml files iteratively down the node tree. It reads the xml file from top down and processes one node at a time until it exhausts all content in the xml file.","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"For a quick run of the program:","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"./run Inputs/hansard/hansard.toml","category":"page"},{"location":"","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper","text":"The documentation page is arranged as follows: Normal usage in terms of inputs and outputs is explained in Usage, and more advanced interaction that includes adding a node or phase type is explained in Advanced usage. The current implementation of different nodes in all phases is shown in Nodes. Function references shows all the docstrings in the program.","category":"page"}]
}
