<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function references · ParlinfoSpeechScraper Documentation</title><meta name="title" content="Function references · ParlinfoSpeechScraper Documentation"/><meta property="og:title" content="Function references · ParlinfoSpeechScraper Documentation"/><meta property="twitter:title" content="Function references · ParlinfoSpeechScraper Documentation"/><meta name="description" content="Documentation for ParlinfoSpeechScraper Documentation."/><meta property="og:description" content="Documentation for ParlinfoSpeechScraper Documentation."/><meta property="twitter:description" content="Documentation for ParlinfoSpeechScraper Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ParlinfoSpeechScraper Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">ParlinfoSpeechScraper</a></li><li><a class="tocitem" href="../download/">XML download</a></li><li><a class="tocitem" href="../sgml2xml/">XML download (1981-1997)</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li><a class="tocitem" href="../advusage/">Advanced Usage</a></li><li><a class="tocitem" href="../nodes/">Nodes</a></li><li class="is-active"><a class="tocitem" href>Function references</a><ul class="internal"><li><a class="tocitem" href="#RunModule"><span>RunModule</span></a></li><li><a class="tocitem" href="#XMLModule"><span>XMLModule</span></a></li><li><a class="tocitem" href="#NodeModule"><span>NodeModule</span></a></li></ul></li><li><a class="tocitem" href="../test/">Testing</a></li><li><a class="tocitem" href="../common_errors/">Common errors and warnings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function references</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function references</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Australian-Parliamentary-Speech/Scraper" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/main/docs/src/functionreference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-references"><a class="docs-heading-anchor" href="#Function-references">Function references</a><a id="Function-references-1"></a><a class="docs-heading-anchor-permalink" href="#Function-references" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.get_args-Tuple{}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.get_args-Tuple{}"><code>ParlinfoSpeechScraper.get_args</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get_args()</p><p>Parse command-line arguments</p><p>This function sets up and parses command-line arguments using the <code>ArgParse</code> package. It defines the arguments that can be passed to the script, including options for verbosity and input file path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/ParlinfoSpeechScraper.jl#L16-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.main-Tuple{Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.main-Tuple{Any, Any}"><code>ParlinfoSpeechScraper.main</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>main(toml_path, verbose)</p><p>Main function to initialize and execute the Parlinfo Speech Scraper</p><p>This function initializes the input configuration from a TOML file specified by <code>toml_path</code> with optional verbosity controlled by <code>verbose</code>. It then runs the ParlinfoSpeechScraper using the configuration.</p><p>Inputs:</p><ul><li><code>toml_path</code>: Path to the TOML configuration file.</li><li><code>verbose</code>: Boolean flag indicating if logging verbosity should be increased.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/ParlinfoSpeechScraper.jl#L54-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.main-Tuple{}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.main-Tuple{}"><code>ParlinfoSpeechScraper.main</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">main()
</code></pre><p>Main function to process command-line arguments and run the program</p><p>This function serves as the entry point of the script. It processes command-line arguments, retrieves the necessary parameters, and calls the main processing function with those parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/ParlinfoSpeechScraper.jl#L39">source</a></section></details></article><h2 id="RunModule"><a class="docs-heading-anchor" href="#RunModule">RunModule</a><a id="RunModule-1"></a><a class="docs-heading-anchor-permalink" href="#RunModule" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.get_date-Tuple{Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.get_date-Tuple{Any}"><code>ParlinfoSpeechScraper.RunModule.get_date</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get_date(fn)</p><p>Get the date from the xml file</p><p>Inputs:</p><ul><li><code>fn</code>: the file directory for the xml file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/RunModule.jl#L25-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.recurse"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.recurse"><code>ParlinfoSpeechScraper.RunModule.recurse</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>recurse(soup, date, PhaseType, xml<em>node, io, index=1, depth=0, max</em>depth=0, node_tree=Vector{Node}())</p><p>Recursively process XML nodes and write data to output</p><p>This function recursively processes XML nodes, extracts relevant data, and writes it to an output stream. It handles node types, depth limitations, and maintains a tree of processed nodes.</p><p>Inputs:</p><ul><li><code>soup</code>: The parsed XML document.</li><li><code>date</code>: The date associated with the XML document.</li><li><code>PhaseType</code>: The phase type determined from the date.</li><li><code>xml_node</code>: The current XML node being processed.</li><li><code>io</code>: The output stream where data is written.</li><li><code>index</code> (optional): The index of the current node (default is 1).</li><li><code>depth</code> (optional): The current depth of recursion (default is 0).</li><li><code>max_depth</code> (optional): The maximum depth for recursion (default is 0, meaning no limit).</li><li><code>node_tree</code> (optional): A vector maintaining the tree of nodes (default is an empty vector).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/RunModule.jl#L297-L314">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.run_ParlinfoSpeechScraper-Tuple{Dict{String, Any}}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.run_ParlinfoSpeechScraper-Tuple{Dict{String, Any}}"><code>ParlinfoSpeechScraper.RunModule.run_ParlinfoSpeechScraper</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>run_ParlinfoSpeechScraper(toml::Dict{String, Any})</p><p>This function processes XML files for parliamentary speeches according to the configuration specified in the provided TOML dictionary. It reads XML file paths, processes each XML file, and outputs the results to a specified directory.</p><p>Inputs:</p><ul><li><code>toml</code>: A dictionary containing configuration options for the scraper.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/RunModule.jl#L87-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.run_xml-NTuple{7, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.run_xml-NTuple{7, Any}"><code>ParlinfoSpeechScraper.RunModule.run_xml</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run_xml(fn, output_path, csv_exist, edit_funcs)</code></pre><p>Process and save XML data to CSV</p><p>This function processes an XML file, extracts relevant data, and saves it to a CSV file. If specified, it also edits the CSV file after creation.</p><p>Inputs:</p><ul><li><code>fn</code>: The file path for the XML file.</li><li><code>output_path</code>: The directory where the processed CSV file will be saved.</li><li><code>csv_exist</code>: Boolean flag indicating if a CSV file already exists.</li><li><code>edit_funcs</code>: list of edit functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/RunModule.jl#L240-L252">source</a></section></details></article><h2 id="XMLModule"><a class="docs-heading-anchor" href="#XMLModule">XMLModule</a><a id="XMLModule-1"></a><a class="docs-heading-anchor-permalink" href="#XMLModule" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.EditModule.edit_main-Tuple{Any, Editor}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.EditModule.edit_main-Tuple{Any, Editor}"><code>ParlinfoSpeechScraper.RunModule.EditModule.edit_main</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>func_list: a list of function names as string editor: a struct with two parameters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/EditModule.jl#L88-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.EditModule.edit_set_up-Tuple{Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.EditModule.edit_set_up-Tuple{Any}"><code>ParlinfoSpeechScraper.RunModule.EditModule.edit_set_up</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>edit<em>set</em>up(headers)</p><p>Sets up a dictionary mapping each element in <code>headers</code> to its corresponding index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/EditModule.jl#L79-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.EditModule.find_all_child_speeches-NTuple{4, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.EditModule.find_all_child_speeches-NTuple{4, Any}"><code>ParlinfoSpeechScraper.RunModule.EditModule.find_all_child_speeches</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>function find<em>all</em>child<em>speeches(row</em>no,rows,header<em>to</em>num,is_written)</p><p>Find all the speeches that belong to a single talker </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/edit_funcs/flatten.jl#L36-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.EditModule.find_all_flags-Tuple{Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.EditModule.find_all_flags-Tuple{Any, Any}"><code>ParlinfoSpeechScraper.RunModule.EditModule.find_all_flags</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get all flags except chamber flag</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/EditModule.jl#L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.EditModule.free_node_op-NTuple{5, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.EditModule.free_node_op-NTuple{5, Any}"><code>ParlinfoSpeechScraper.RunModule.EditModule.free_node_op</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>if it is free flowing, check if it is same debate and add it to the previous one</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/edit_funcs/free_node.jl#L49">source</a></section></details></article><h2 id="NodeModule"><a class="docs-heading-anchor" href="#NodeModule">NodeModule</a><a id="NodeModule-1"></a><a class="docs-heading-anchor-permalink" href="#NodeModule" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.define_flags-Tuple{Node, Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.define_flags-Tuple{Node, Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.define_flags</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>define<em>flags(node::Node{&lt;:AbstractNode{&lt;:AbstractPhase}}, node</em>tree)</p><p>Generates flags based on the characteristics of the given <code>node</code>.</p><p>Inputs:</p><ul><li><code>node</code>: A <code>Node</code> struct.</li><li><code>node_tree</code>: A vector representing a tree of nodes for context.</li></ul><p>Returns:</p><ul><li>An array of flags indicating characteristics of <code>node</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L384-L395">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.define_flags-Tuple{Node{&lt;:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}, Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.define_flags-Tuple{Node{&lt;:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}, Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.define_flags</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>define<em>flags(node::Node{&lt;:AbstractNode{Phase2011}},parent</em>node,node_tree)</p><p>Added petition and quote nodes on top of the previous flags</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/Phases/Phase2011/Phase2011.jl#L23-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.detect_node_type-NTuple{4, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.detect_node_type-NTuple{4, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.detect_node_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>detect<em>node</em>type(node, node_tree, date, soup, PhaseType)</p><p>default setting:</p><p>Inputs:</p><ul><li><code>node</code>: The XML node to determine the type for.</li><li><code>node_tree</code>: A vector representing a tree of nodes</li><li><code>soup</code>: The root node.</li><li><code>PhaseType</code>: The phase type determined from the date of XML.</li></ul><p>Returns:</p><ul><li>The detected node type (<code>NodeType</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L182-L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.detect_phase-Tuple{Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.detect_phase-Tuple{Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.detect_phase</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>detect<em>phase(date, which</em>house)</p><p>Inputs:</p><ul><li><code>date</code>: A floating-point number representing the date to detect the phase for.</li><li><code>house</code>: A string that indicates either senate or house</li></ul><p>Returns:</p><ul><li>The phase associated with the provided <code>date</code>, or <code>AbstractPhase</code> if no specific phase is found.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L66-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.find_chamber-Tuple{Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.find_chamber-Tuple{Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.find_chamber</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>find<em>chamber(node, node</em>tree)</p><p>Identifies the type of chamber associated with the given XML <code>node</code>.</p><p>Inputs:</p><ul><li><code>node</code>: The XML node </li><li><code>node_tree</code>: A vector representing a tree of nodes for context.</li></ul><p>Returns:</p><ul><li>An integer indicating the chamber type:<ul><li><code>2</code> for a federal chamber (<code>FedChamberNode</code>).</li><li><code>1</code> for a chamber (<code>ChamberNode</code>).</li><li><code>0</code> if no chamber node is found.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L336-L350">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.find_section_title-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.find_section_title-Tuple{Any, Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.find_section_title</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>find<em>section</em>title(node<em>tree, soup, section</em>type)</p><p>Inputs:</p><ul><li><code>node</code>: The XML node from which to extract the section title.</li><li><code>node_tree</code>: A vector representing a tree of nodes for context.</li><li><code>soup</code>: The root node of the XML document.</li><li><code>section_type</code>: The nodenames of the types of section nodes where the title is wanted. For example, &quot;speech&quot;.</li></ul><p>Returns:</p><ul><li>The title of the specified <code>section_type</code> found within the XML document, or &quot;N/A&quot; if not found.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L433-L444">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.find_talker_in_p-Tuple{Node{&lt;:PNode}}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.find_talker_in_p-Tuple{Node{&lt;:PNode}}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.find_talker_in_p</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>find<em>talker</em>in<em>p(p</em>node)</p><p>If the p<em>node is not the first p</em>node, we check if there is a talker inside the p_node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/PNode.jl#L181-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.get_all_subtypes"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.get_all_subtypes"><code>ParlinfoSpeechScraper.RunModule.NodeModule.get_all_subtypes</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_all_subtypes(type, st=[])</code></pre><p>Get every subtype of the provided <code>type</code> parameter.</p><p>Inputs:</p><ul><li><code>type</code>: the provided type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L123-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{&lt;:PNode}}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{&lt;:PNode}}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.get_sections</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get_sections(::Type{&lt;:PNode})</p><p>In which sections are the p_node wanted as default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/PNode.jl#L248-L252">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.get_sections</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get_sections(::Type{PNode{Phase2011}})</p><p>Allowed sections for PNodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/Phases/Phase2011/nodes/PNode.jl#L10-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.PhaseSGML}}}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.PhaseSGML}}}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.get_sections</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get_sections(::Type{PNode{PhaseSGML}})</p><p>Allowed sections for PNodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/Phases/PhaseSGML/nodes/PNode.jl#L10-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.get_talker_from_parent-Tuple{Node, Node}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.get_talker_from_parent-Tuple{Node, Node}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.get_talker_from_parent</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get<em>talker</em>from<em>parent(node::Node,parent</em>node::Node)</p><p>It finds the speaker information from the parent node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L272-L276">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{&lt;:InterTalkNode}}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{&lt;:InterTalkNode}}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get_xpaths(::Type{&lt;:InterTalkNode})</p><p>The default setting for what nodenames are allowed for intertalknode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/InterTalkNode.jl#L5-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{&lt;:PNode}}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{&lt;:PNode}}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get_xpaths(::Type{&lt;:PNode})</p><p>Find what the p_node is called in xml for default</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/PNode.jl#L239-L243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get_xpaths(::Type{PNode{Phase2011}})</p><p>&quot;para&quot; as accepted xpaths for PNode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/Phases/Phase2011/nodes/PNode.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.PhaseSGML}}}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.PhaseSGML}}}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get_xpaths(::Type{PNode{PhaseSGML}})</p><p>&quot;para&quot; as accepted xpaths for PNode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/Phases/PhaseSGML/nodes/PNode.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Union{Tuple{Type{&lt;:N}}, Tuple{N}} where N&lt;:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Union{Tuple{Type{&lt;:N}}, Tuple{N}} where N&lt;:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode"><code>ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>get_xpaths(::Type{&lt;:N}) where {N &lt;: AbstractNode}</p><p>This function serves as a placeholder and returns an empty array, which is meant to provide the nodenames allowed for each type. For example, speech nodes can have names &quot;speech&quot; or &quot;continue&quot;. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L263-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type-Tuple{Node{&lt;:PNode}, Any, Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type-Tuple{Node{&lt;:PNode}, Any, Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>is<em>first</em>node<em>type(node::Node{&lt;:PNode},parent</em>node,allowed<em>names,node</em>tree)</p><p>This default function detects if the p<em>node detected is the first p</em>node under a parent node. The reason for this is that if the p_node is not the first node, there are alternative checks to see if the talker has changed since the first one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/PNode.jl#L101-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type-Tuple{Node{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}, Any, Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type-Tuple{Node{PNode{ParlinfoSpeechScraper.RunModule.NodeModule.Phase2011}}, Any, Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>is<em>first</em>node<em>type(node::Node{PNode{Phase2011}},parent</em>node,allowed<em>names,node</em>tree)</p><p>A different method to detect if the pnode is the first pnode for this phase</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/Phases/Phase2011/nodes/PNode.jl#L19-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{&lt;:PNode}, Type{&lt;:AbstractPhase}, Any, Vararg{Any}}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{&lt;:PNode}, Type{&lt;:AbstractPhase}, Any, Vararg{Any}}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>is<em>nodetype(node, node</em>tree, nodetype::Type{&lt;:PNode},phase::Type{&lt;:AbstractPhase},soup, args...; kwargs...) </p><p>This function detects whether the given xml node is PNode. This function takes the phase into account aswell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/PNode.jl#L257-L261">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{&lt;:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode}, Type{&lt;:AbstractPhase}, Any, Vararg{Any}}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{&lt;:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode}, Type{&lt;:AbstractPhase}, Any, Vararg{Any}}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>is<em>nodetype(node, node</em>tree, nodetype::Type{&lt;:AbstractNode}, phase::Type{&lt;:AbstractPhase}, soup, args...; kwargs...)</p><p>default setting:</p><p>Inputs:</p><ul><li><code>node</code>: The XML node to evaluate.</li><li><code>node_tree</code>: A vector representing a tree of nodes for context.</li><li><code>nodetype</code>: A subtype of <code>AbstractNode</code> representing the type of node to check against.</li><li><code>phase</code>: A subtype of <code>AbstractPhase</code> representing the phase associated with the node.</li><li><code>soup</code>: The root node.</li><li><code>args...</code>: Optional additional arguments.</li><li><code>kwargs...</code>: Optional keyword arguments.</li></ul><p>Returns:</p><ul><li><code>true</code> if the name of <code>node</code> is found in the allowed names associated with <code>nodetype</code> for the given <code>phase</code>, <code>false</code> otherwise.</li></ul><p>Notes: More specific detection method for nodes is defined in nodes/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L236-L255">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.p_with_a_as_parent-Tuple{Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.p_with_a_as_parent-Tuple{Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.p_with_a_as_parent</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>p<em>with</em>a<em>as</em>parent(p_node)</p><p>If no talker is found for the first node, we look for a &quot;a&quot; as parentnode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/PNode.jl#L208-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.parse_node-Tuple{Node, Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.parse_node-Tuple{Node, Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.parse_node</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>parse<em>node(node::Node, node</em>tree, io)</p><p>default setting:</p><p>Inputs:</p><ul><li><code>node</code>: xml node of Node struct</li><li><code>node_tree</code>: A vector representing a tree of nodes for context.</li><li><code>io</code>: The output stream where processed data is written.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L204-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.parse_node-Tuple{Node{&lt;:PNode}, Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.parse_node-Tuple{Node{&lt;:PNode}, Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.parse_node</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>parse<em>node(node::Node{&lt;:PNode},node</em>tree,io)</p><p>The default function to take a p_node and write to the csv</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/PNode.jl#L276-L280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.process_node</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>process<em>node(node::Node, node</em>tree)</p><p>default setting:</p><p>Inputs:</p><ul><li><code>node</code>: xml node of Node struct</li><li><code>node_tree</code>: A vector representing a tree of nodes for context.</li></ul><p>Notes:</p><ul><li>This function is typically invoked when no specific processing behavior is defined for the <code>NodeType</code> associated with <code>node</code>.</li><li>Users may customize or define specific behaviors for different <code>NodeType</code> instances within their implementation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L218-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node{&lt;:PNode}, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node{&lt;:PNode}, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.process_node</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>process<em>node(node::Node{&lt;:PNode},node</em>tree)</p><p>If no particular phase is specified, this default version of process node is run. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/nodes/PNode.jl#L51-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_name-Tuple{Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_name-Tuple{Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_name</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>reverse<em>find</em>first<em>node</em>name(node_tree, names)</p><p>Inputs:</p><ul><li><code>node_tree</code>: A vector representing a tree of nodes to search in reverse order.</li><li><code>names</code>: A collection of node names to search for.</li></ul><p>Returns:</p><ul><li>The first node from <code>node_tree</code> in reverse order whose name is in the <code>names</code> collection, or <code>nothing</code> if no such node is found.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L141-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_not_name-Tuple{Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_not_name-Tuple{Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_not_name</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>revers<em>find</em>first<em>node</em>not<em>name(node</em>tree, names)</p><p>Inputs:</p><ul><li><code>node_tree</code>: A vector representing a tree of nodes to search in reverse order.</li><li><code>names</code>: A collection of node names. The function searches for the first node from <code>node_tree</code> in reverse order whose name is not in this collection.</li></ul><p>Returns:</p><ul><li>The first node from <code>node_tree</code> in reverse order whose name is not in the <code>names</code> collection, or <code>nothing</code> if no such node is found.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L162-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ParlinfoSpeechScraper.RunModule.NodeModule.write_test_xml-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#ParlinfoSpeechScraper.RunModule.NodeModule.write_test_xml-Tuple{Any, Any, Any}"><code>ParlinfoSpeechScraper.RunModule.NodeModule.write_test_xml</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Writes the test xmls for all edge cases: it cannot handle dummy parent as root itself – soup is getting passed and not document type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Australian-Parliamentary-Speech/Scraper/blob/92addf2efed04c25dc5f1561d3d729b577b1a3cc/src/NodeModule.jl#L509-L511">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nodes/">« Nodes</a><a class="docs-footer-nextpage" href="../test/">Testing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 21 January 2026 01:36">Wednesday 21 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
